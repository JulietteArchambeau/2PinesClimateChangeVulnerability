---
title: "Scots pine genomic data"
subtitle: "Neutral population genetic structure and variance partitioning"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
number-sections: true
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 7,fig.height = 5,cache=F)
options(width = 300)
library(knitr)
library(tidyverse)
library(readxl)
library(magrittr)
library(kableExtra)
library(reshape2)
library(here)
library(geosphere) # to calculate the geodesic distances
library(adespatial) # to calculate dbMEMs
library(vegan) # to run the PCA and the RDA
library(pals) # R color palettes with many data classes

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
source(here("scripts/functions/format_clim.R"))
```

# The data

## Population genetic structure 
 
We explore the neutral population genetic structure of the Scots pine genomic data with a Principal Component Analyses (PCA).

### Individuals allele counts

We first look at the population genetic structure with the individual allele counts (not filtered for MAF, minor allele frequencies).

```{r LoadIndividualAlleleCounts}
# We load the imputed allele counts not filtered for MAF
geno <- readRDS(here("data/ScotsPine/GenomicData/FormattedData/ImputedFilteredGenomicData.rds")) %>% 
  arrange(PopulationCode) # to be sure that colors in the PCA graph are attributed to the right individuals

geno[1:10,1:10] %>% kable_mydf()
```

```{r PCAIndividualAlleleCounts, eval=F}
# Run the PCA (quite long)
pca <- rda(geno[,-c(1:3)], scale=T)

saveRDS(pca,here("outputs/ScotsPine/ExploratoryAnalyses/PCA_IndividualAlleleCounts.rds"))
```

```{r LoadPCAIndividualAlleleCounts}
pca <- readRDS(here("outputs/ScotsPine/ExploratoryAnalyses/PCA_IndividualAlleleCounts.rds"))
```

Screeplot of the PCA eigenvalues:

```{r ScreeplotIndividualAlleleCounts, fig.height=4, fig.width=6}
# Screeplot of the PCA eigenvalues
screeplot(pca, type = "barplot", npcs=10, main="PCA Eigenvalues")
```

```{r PCAplotIndividualAlleleCounts, fig.height=8, fig.width=8}
# Add population colors to the genomic dataset
geno_plot <- tibble(PopulationCode = unique(geno$PopulationCode),
                    PopulationColor = cols25(length(unique(geno$PopulationCode)))) %>% 
  right_join(geno, by="PopulationCode") %>% 
  arrange(PopulationCode)

# We plot only the first and second axis
second_axis <- 2

plot(pca, type="n", scaling=3, choices=c(1,second_axis),
     xlab=paste0("PC1 (",round(summary(eigenvals(pca))[2,1]*100,2),"%)"),
     ylab=paste0("PC",second_axis," (",round(summary(eigenvals(pca))[2,second_axis]*100,2),"%)"))
points(pca, display="sites", pch=21, cex=0.9, 
         col=geno_plot$PopulationColor, 
         scaling=3, 
         bg=geno_plot$PopulationColor, choices=c(1,second_axis))
legend("topleft", 
       legend=unique(geno_plot$PopulationCode), 
       bty="n", 
       col=unique(geno_plot$PopulationColor), 
       pch=21, 
       cex=0.9,
       ncol = 3,
       pt.bg=unique(geno_plot$PopulationColor), 
       title="Populations")
```

### Population allele frequencies 

We then look at the population genetic structure with the population allele frequencies.

```{r LoadPopulationAlleleFrequencies}
# We load the population allele frequencies not filtered for MAF
geno <- readRDS(here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData_PopAlleleFreq.rds")) %>% 
  arrange(PopulationCode)  # to be sure that colors in the PCA graph are attributed to the right individuals
  
geno[1:10,1:10] %>% kable_mydf()

# we run the PCA 
pca <- rda(geno %>% column_to_rownames("PopulationCode"), scale=T)
```

Screeplot of the PCA eigenvalues:

```{r ScreeplotPopulationAlleleFrequencies, fig.height=4, fig.width=6}
# Screeplot of the PCA eigenvalues
screeplot(pca, type = "barplot", npcs=10, main="PCA Eigenvalues")
```

```{r PCAplotPopulationAlleleFrequencies, fig.height=8, fig.width=8}
# Add population colors to the genomic dataset
geno_plot <- tibble(PopulationCode = unique(geno$PopulationCode),
                    PopulationColor = cols25(length(unique(geno$PopulationCode)))) %>% 
  right_join(geno, by="PopulationCode") %>% 
  arrange(PopulationCode)

second_axis <- 2

plot_pca_allele_freq <- function(second_axis){
  
  ordipointlabel(pca, 
                 display="sites", # show population names
                 scaling=3, 
                 pch=21, 
                 cex=1, 
                 xlab=paste0("PC1 (",round(summary(eigenvals(pca))[2,1]*100,2),"%)"),
                 ylab=paste0("PC",second_axis," (",round(summary(eigenvals(pca))[2,second_axis]*100,2),"%)"),
                 col=geno_plot$PopulationColor, 
                 bg=geno_plot$PopulationColor, 
                 choices=c(1,second_axis))
  }

plot_pca_allele_freq(second_axis = 2)
plot_pca_allele_freq(second_axis = 3)
```

We extract the first three PCs of the PCA for the following steps.

```{r ExtractPCs}
# We extract the first three PCs of the PCA
pgsdf <- scores(pca, choices=c(1:2), display="sites", scaling="none") %>% 
  as.data.frame() %>% 
  rownames_to_column("PopulationCode") %>% 
  dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.))) %>% 
  as_tibble()
```


## Climatic data

The climatic variables come from the CHESS-SCAPE climatic database, see here for details on this data and for visualizing climatic variation:
<https://juliettearchambeau.shinyapps.io/VizClimateDifferencesScotsPine/>.

Some details on the choice of the climatic variables are given in the report `ExploreChessCapeClimaticData.html`.

Correlations among the selected climatic variables can be visualized with the following shinny app : <https://juliettearchambeau.shinyapps.io/VizClimateDifferencesScotsPine_SelectedVariables/>.


```{r LoadClimaticData}
# climatic dataset
climdf <- readRDS(here("data/ScotsPine/subdf.rds"))

# selected climatic variables
clim_var_avg_selected <- unique(climdf$clim_var_avg)
```


## Distance-based Moran's Eigenvector Maps (dbMEMs)

Some papers/resources :

 - The vignette [Moran’s Eigenvector Maps and related methods for the spatial multiscale analysis of ecological data](https://cran.r-project.org/web/packages/adespatial/vignettes/tutorial.html) by Stéphane Dray.

 - @draySpatialModellingComprehensive2006
 
 - @forester2018comparing
 
 - @gutakerGenomicHistoryEcology2020
 
 - @laskyGenomeenvironmentAssociationsSorghum2015
 
Moran’s Eigenvector Maps (MEMs) are calculated based on a spatial weighting matrix (SWM) and are orthogonal vectors maximizing the spatial autocorrelation (measured by Moran’s coefficient) of the sampled locations. Distance-based MEMs are calculated based on a particular SWM which is a geographic distance matrix. 
 
Using the function `distm` from the R package `geosphere`, we first calculate a matrix of geodesic distances (in meters) among population locations using [great-circle distances](https://en.wikipedia.org/wiki/Great-circle_distance) calculated for the WGS84 ellipsoid. The shortest path between two points on an ellipsoid is called the geodesic. The WGS84 ellipsoid is the best available global ellipsoid.

Then we calculate the dbMEMs with the function `dbmem` of the `adespatial` R package. Similarly to @laskyGenomeenvironmentAssociationsSorghum2015, we only keep MEMs with positive eigenvalues. 

We get a message informing the we do not use Euclidean distances, but that's ok, we do not have to convert geodesic distances to Euclidean distances.


```{r CalculatedbMEMs}
popdf <- climdf %>% 
  dplyr::select(PopulationCode,Longitude, Latitude) %>% 
  distinct()

dbmems <- popdf %>% 
  dplyr::select(Longitude, Latitude) %>% 
  distm(fun = distGeo) %>% # calculate the geodesic distances in meters
  as.dist() %>%  
  dbmem(MEM.autocor = "positive") %>% 
  bind_cols(popdf,.)
```


## Merging climate, population structure and dbMEMs

We merge the climatic data with the dbMEMs and the population genetic structure data.

```{r AdddbMEMsToClimDataset}
df <- climdf %>%
  left_join(dbmems, by=c("PopulationCode","Latitude","Longitude")) %>% 
  left_join(pgsdf, by="PopulationCode")
```

# Variance partitioning

We aim to disentangle the *relative contribution* of climate, neutral population genetic structure (accounted for with the first three PC scores) and geography (accounted for by the distance-based Moran's eigenvector maps with positive eigenvalues) in explaining the genomic variation.

For that, we run:

  - one *full* RDA with all factors (population structure, climate and geographical distance), i.e. no variable conditioning.
  
  - three *partial* RDA in which the factor of interest is conditioned by the other two factors.


```{r FunctionVarPart}
# Function to calculate the 
var_part <- function(df_geno, 
                     clim_var_avg_selected, 
                     df_var, 
                     scale_rda, 
                     center_rda){

# Build formulas of the RDA models
# ================================
form_clim_var <- paste(clim_var_avg_selected,collapse= " + ") # climatic variables
form_pgs_var <- colnames(df_var) %>% stringr::str_subset("^PC") %>%  paste(collapse= " + ") # pop structure

form_geo_var <- colnames(df_var) %>%  
    stringr::str_subset("MEM") %>%  
   `[`(1:length(.)) %>% # keep only the n first MEMs
    paste(collapse= " + ") # coordinates

# Model formulas
form_full_rda <- paste("df_geno ~ ",
                       paste(c(form_clim_var,form_pgs_var,form_geo_var),collapse=" + " )) %>% 
  as.formula()

form_clim_rda <- paste("df_geno ~ ",
                       form_clim_var,"+ Condition(",paste(c(form_pgs_var,form_geo_var),collapse=" + " ), ")") %>% 
  as.formula()

form_pgs_rda <- paste("df_geno ~ ",
                       form_pgs_var,"+ Condition(",paste(c(form_clim_var,form_geo_var),collapse=" + " ), ")") %>% 
  as.formula()

form.geo_rda <- paste("df_geno ~ ",
                       form_geo_var,"+ Condition(",paste(c(form_clim_var,form_pgs_var),collapse=" + " ), ")") %>% 
  as.formula()


# Run the RDA models
# ==================

# Full RDA
full_rda <- rda(form_full_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda) 
anova_full_rda <- anova(full_rda)

# Partial RDA: pure climatic model
clim_rda <- rda(form_clim_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_clim_rda <- anova(clim_rda)

# Partial RDA: pure neutral population structure model
pgs_rda <- rda(form_pgs_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_pgs_rda <- anova(pgs_rda)

# Partial RDA: pure geography model
geo_rda <- rda(form.geo_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_geo_rda <- anova(geo_rda)


# Summary table
# =============

sum_tab_RDA <- tibble("RDA models"=c("Full model: Y ~ clim + geo + pgs.",
                      "Pure climate model: Y ~ clim | (geo + pgs)",
                      "Pure pop. gen. structure model: Y ~ pgs | (geo + clim)",
                      "Pure geography model: Y ~ geo | (pgs + clim)"),
       "Total exp. variance"=c(RsquareAdj(full_rda)[[1]],
              RsquareAdj(clim_rda)[[1]],
              RsquareAdj(pgs_rda)[[1]],
              RsquareAdj(geo_rda)[[1]]),
       "Relative exp. variance"=c(1,
                                  RsquareAdj(clim_rda)[[1]]/RsquareAdj(full_rda)[[1]],
                                  RsquareAdj(pgs_rda)[[1]]/RsquareAdj(full_rda)[[1]],
                                  RsquareAdj(geo_rda)[[1]]/RsquareAdj(full_rda)[[1]]),
       "P-value"=c(anova_full_rda[["Pr(>F)"]][[1]],
                   anova_clim_rda[["Pr(>F)"]][[1]],
                   anova_pgs_rda[["Pr(>F)"]][[1]],
                   anova_geo_rda[["Pr(>F)"]][[1]]))

# # Export the table in latex
# xtable(sum_tab_RDA, type = "latex",digits=2) %>% 
#   print(file = here(paste0("tables/VariancePartitioningRDA_EM",EM_i,".tex")), include.rownames=FALSE)

return(sum_tab_RDA)
}
```

```{r VarPartForEachEM, eval=F}
# Variance partionning estimated with the different EM
list_varpart <- lapply(unique(climdf$ensemble_member), function(EM_i){
  
  format_clim(df, 
              EM = EM_i, 
              RCP = "RCP2.6", 
              fut_timeslice = "2030-2050", 
              clim_var_avg_selected)$climdf_ref_scaled %>% 
    dplyr::select(starts_with("MEM"),
                  contains("PC"),
                  any_of(clim_var_avg_selected)) %>% 
    var_part(df_geno=geno[,-1],
             clim_var_avg_selected=clim_var_avg_selected,
             df_var=.,
             scale_rda=F,
             center_rda=F)
  
}) %>% setNames(unique(climdf$ensemble_member))

saveRDS(list_varpart, here("outputs/ScotsPine/ExploratoryAnalyses/VarPart.rds"))
```

Ensemble member `01`:

```{r ShowOuputsVarPartEM01}
list_varpart <- readRDS(file=here("outputs/ScotsPine/ExploratoryAnalyses/VarPart.rds"))

# Ensemble member 01
kable_mydf(list_varpart$`01`, round_number = 4, boldfirstcolumn = T)
```

Ensemble member `04`:

```{r ShowOuputsVarPartEM04}
# Ensemble member 04
kable_mydf(list_varpart$`04`, round_number = 4, boldfirstcolumn = T)
```

Ensemble member `06`:

```{r ShowOuputsVarPartEM06}
# Ensemble member 06
kable_mydf(list_varpart$`06`, round_number = 4, boldfirstcolumn = T)
```

Ensemble member `15`:

```{r ShowOuputsVarPartEM15}
# Ensemble member 15
kable_mydf(list_varpart$`15`, round_number = 4, boldfirstcolumn = T)
```

**<span style="color: red;">Interpretation</span>**

Very little differences among ensemble members, so we can only show the results from one model in the paper (SI).

About 60% of genomic variation can be explained by the three factors: climate, geography and population genetic structure.
23% of genomic variation (more than 1/3 of the variance explained by the three factors combined) can be explained by climate alone. In contrast, population genetic structure and geography alone explain less genomic variation, about 9% and 18% respectively.

As a comparison, in maritime pine, about 80% of genomic variation can be explained by the three factors, but climate can only explain 8% alone. 