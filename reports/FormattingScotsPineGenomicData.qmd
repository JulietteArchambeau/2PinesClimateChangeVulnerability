---
title: "Scots pine genomic data"
subtitle: "Formatting, filtering, imputation of missing data, genetic relationships"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
number-sections: true
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 7,fig.height = 5,cache=F)
options(width = 300)
library(knitr)
library(dplyr)
library(tidyverse)
library(readxl)
library(magrittr)
library(kableExtra)
library(genetics)
library(xtable)
library(reshape2)
library(janitor)
library(diffdf)
library(parallel)
library(here)
library(AGHmatrix) # to estimate the genetic relatedness matrix 

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
```

In the present report, we apply the following steps to Scots pine genomic data:

  - formatting for the following analyses (e.g., letters replaced by 0, 1 and 2), 
  
  - filtering for minor allele counts, minor allele frequencies, missing data per clone and per SNP),
  
  - imputation of missing data based on the most common SNP value within the family,
  
  - estimation of the genetic relatedness coefficients (to identify full siblings or individuals to which the wrong genotype was attributed, for instance because of genotyping error or mistake during field sampling or the following molecular analyses).
  
We also have a look at SNP positions on the genome and we identify SNPs which are statistically correlated.

# Raw genomic data

## Loading

Here are the 10 first rows and columns of the original genomic dataset.

```{r LoadRawGenomicData}
# Load the raw genomic data:
raw_data <- read_table(here("data/ScotsPine/GenomicData/newLEAF_nodups.txt"),show_col_types=F) %>%
  dplyr::select(probesetid,sort(colnames(.)))

# viz
raw_data[1:10,1:10] %>% kable_mydf(boldfirstcolumn = T, font_size = 11)
```

The original genomic dataset includes **`r ncol(raw_data)-1` individuals** (columns) and **`r nrow(raw_data)` SNPs** (rows).

```{r UniqueValueNames, eval=F}
# to check unique values in the dataset
# and identify how missing data are encoded
unique(unlist(raw_data[,-1]))

# output: "GG" "AA" "TG" "AC" "CC" "TT" "NN" "CG" "AG" "TC" "AT"
```

In the original genomic dataset, missing data are encoded with `NN`.

Formatting: for each SNP, we convert the letters (e.g. AA, AG) to numbers (0,1 or 2), and we encode missing data with `NA`.

```{r FormattingRawGenomicDataFromLettersToNumbers, eval=F}
# We apply a function to each column (i.e SNP) of the raw genomic data, 
# after removing the first two columns, i.e. the clone ID and the assay in which the clone was genotyped

data <- raw_data %>% column_to_rownames(var="probesetid") %>% t() %>% as.data.frame()


list_alleles <- lapply(colnames(data), function(x){ 
  
  vec <- data[,x]
  
  tab <- table(data[,x]) %>%  as.matrix() %>%  t() %>% as.data.frame() %>% dplyr::select(-contains("NN"))
  
  
  if(length(colnames(tab))==1){         # monomorphic case, e.g. only A/A
    major <- names(which.max(tab))
    
    case_when(vec == major ~ 0) 
    
  } else if(length(colnames(tab))==2){  # case where there is no homozygote with the rare allele, e.g. A/A and A/G
    
    major <- names(which.max(tab))
    mid <- names(which.min(tab))
    
    case_when(vec == major ~ 0,
              vec == mid   ~ 1) 
    
  } else if (length(colnames(tab))==3){ # common case, e.g. A/A, A/G and G/G
    
    if(tab[,1]==tab[,3]){               # to account for cases where there is the same number of A/A and G/G 
      major <- colnames(tab)[1]
      minor <- colnames(tab)[3]
      } else {
    major <- names(which.max(tab[,c(1,3)]))
    minor <- names(which.min(tab[,c(1,3)]))
      }
    mid <- setdiff(names(tab),c(major,minor))  
    
    case_when(vec == major ~ 0,
              vec == minor ~ 2,
              vec == mid   ~ 1) 
  }
}) %>% setNames(colnames(data)) # re-attribute the SNP ID to list names

df <- list_alleles %>% 
  as_tibble() %>% 
  t() %>% 
  set_colnames(rownames(data)) %>% # attribute individual ID
  as.data.frame()

# save the dataset
df %>% saveRDS(here("data/ScotsPine/GenomicData/geno.rds"))
```

Here are the 10 first rows and columns of the formatted dataset. 

```{r LoadgGenomicData}
df <- readRDS(here("data/ScotsPine/GenomicData/geno.rds"))

# viz
df[1:10,1:10] %>% kable_mydf(boldfirstcolumn = T, font_size = 11)
```


# Filtering genomic data

## MAC and monomorphic SNPs{#MAC}

```{r FunctionCalculateMAC}
# function to calculate the minor allele counts
sum_minor_allele <- function(x){df %>% 
  t() %>% 
  as_tibble() %>% 
  sapply(function(x) sum(x,na.rm=T)) %>% 
  as.data.frame() %>%
  set_colnames(c("sum")) %>% 
  rownames_to_column(var = "snp") %>% 
  as_tibble() 
}
```

```{r IdentifyingMonomorphicSNPs, eval=T}
mono <- df %>% sum_minor_allele %>% filter(sum==0)
low_mac <- df %>% sum_minor_allele %>% filter(sum %in% c(1,2))
```

`r nrow(mono)` SNPs are monomorphic. We remove them.

`r nrow(low_mac)` SNPs have one or two minor allele count (MAC). We also remove these SNPs as the minor alleles may be due to PCR or sequencing errors.


```{r RemovingMonomorphicSNPs, eval=T}
df <- df[!(row.names(df) %in% mono$snp),]
df <- df[!(row.names(df) %in% low_mac$snp),]
```

<span style="color: red;">After filtering monomorphic SNPs and MAC, `r nrow(df)` SNPs left.</span>


## NAs and MAF

### Missing data per clone

```{r MissingDataPerIndividual, warning=F, fig.height=6,fig.width=8}
tab <- df %>% 
  as_tibble() %>% 
  sapply(function(x) sum(is.na(x))*100/nrow(df)) %>% 
  as.data.frame() %>%
  set_colnames(c("na_freq")) %>% 
  rownames_to_column(var = "clone") %>% 
  as_tibble() %>% 
  arrange(na_freq) %>% 
  mutate(id=1:nrow(.))

plot(tab$id,tab$na_freq,
     pch=20,
     xlab="Individual number",
     ylab="Percentage of missing data per individual")
```

All individuals have less than `r max(tab$na_freq) %>% round(2)`% missing data. Therefore, we do not apply a filter of missing data per individual. 

### Minor allele frequencies

We want to remove *minor allele frequencies* (MAF) for gene-environment association analyses, but not for population genetic structure estimation. Therefore, we produce two datasets: one with MAF and the other without. We store the two datasets in a list.

```{r MAF, warning=F, fig.height=6,fig.width=8}
tab <- df %>% 
  t() %>% 
  as_tibble() %>% 
  sapply(function(x) sum(x,na.rm=T)*100/(2*nrow(.))) %>% 
  as.data.frame() %>%
  set_colnames(c("MAF")) %>% 
  rownames_to_column(var = "snp") %>% 
  as_tibble() %>% 
  arrange(MAF) %>% 
  mutate(id=1:nrow(.))

plot(tab$id,tab$MAF,
     pch=20,
     xlab="SNP number",
     ylab="Minor allele frequencies")
```

```{r RmMissingDataMAF}
list_geno <- list(list_withmaf=list(df = df),
                  list_withoutmaf=list(df = df[!(row.names(df) %in% tab[tab$MAF<1,]$snp),]))
```

<span style="color: red;">`r nrow(tab[tab$MAF<1,])` SNPs have MAF < 1%. In the dataset without MAF, we remove the SNPs with MAF < 1%: there are `r nrow(list_geno$list_withoutmaf$df)` SNPs left.</span> 


### Missing data per SNP

```{r MissingDataPerSNP, warning=F}
identify_NA_perSNP <- function(x){
  
  x$df %>% 
    t() %>% 
    as_tibble() %>% 
    sapply(function(x) sum(is.na(x))*100/nrow(.)) %>% 
    as.data.frame() %>%
    set_colnames(c("na_freq")) %>% 
    rownames_to_column(var = "snp") %>% 
    as_tibble() %>% 
    arrange(na_freq) %>% 
    mutate(id=1:nrow(.))
}

NAfreq_per_SNP <- lapply(list_geno,identify_NA_perSNP)
```


In the dataset without MAF, the maximum percentage of missing data per SNP is `r max(NAfreq_per_SNP$list_withoutmaf$na_freq) %>% round(2)`%.

In the dataset with MAF, the maximum percentage of missing data per SNP is `r max(NAfreq_per_SNP$list_withmaf$na_freq) %>% round(2)`%.

Therefore, we do not apply a filter for the percentage of missing data per SNP and we keep all the SNPs.

```{r PlotMissingDataPerSNP, fig.height=6,fig.width=8}
plot(NAfreq_per_SNP$list_withoutmaf$id,NAfreq_per_SNP$list_withoutmaf$na_freq,
     pch=20,
     xlab="SNP number",
     ylab="Percentage of missing data per SNP",
     main="Genomic dataset without MAF")

plot(NAfreq_per_SNP$list_withmaf$id,NAfreq_per_SNP$list_withmaf$na_freq,
     pch=20,
     xlab="SNP number",
     ylab="Percentage of missing data per SNP",
     main="Genomic dataset with MAF")
```


## Exporting the filtered datasets

After the filtering steps: 

  - <span style="color: red;">`r nrow(list_geno$list_withmaf$df)` SNPs and `r ncol(list_geno$list_withmaf$df)` individuals in the dataset not filtered for MAF.</span>

  - <span style="color: red;">`r nrow(list_geno$list_withoutmaf$df)` SNPs and `r ncol(list_geno$list_withoutmaf$df)` individuals in the dataset filtered for MAF.</span>

We format the two datasets with SNPs in columns and individuals in rows. And we add two columns with information about the family and the population of each individual. 

We show below the first 10 rows and columns of the dataset not filtered for MAF.

```{r FormattingFilteredDatasets}
# We load a dataset containing population and family for each individual
field_data <- read_excel(here("data/ScotsPine/Field.xlsx"), na = "NA") %>% 
  dplyr::select(PopulationCode,Family, FieldCode) %>% 
  mutate(FieldCode = as.character(FieldCode))


list_geno <- lapply(list_geno, function(x){
  
  # we invert the dataset with tidyverse (quite long)
  df <- x$df %>% 
  rownames_to_column("SNP") %>%
  pivot_longer(-SNP, names_to = "FieldCode", values_to = "Value") %>%
  pivot_wider(names_from = SNP, values_from = Value)

  # we merge the two datasets
  field_data %>% right_join(df, by="FieldCode")
  
})

list_geno$list_withmaf[1:10,1:10] %>% kable_mydf()
```


### Allele counts

We export allele counts.

```{r SavingFilteredDatasets}
# we save the dataset not filtered for MAF
saveRDS(list_geno$list_withmaf, here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData.rds"))

# we save the dataset without MAF
saveRDS(list_geno$list_withoutmaf, here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData_noMAF.rds"))
```

### Allele frequencies

We calculate the population allele frequencies.

```{r CalculatePopulationAlleledFrequencies}
# Function to calculate the population allele frequencies
compute_allele_freq <- function(x){
  x %>% 
    dplyr::select(PopulationCode, contains("AX")) %>% 
    group_by(PopulationCode) %>% 
    summarise_all(~sum(., na.rm = TRUE)/((n()-sum(is.na(.)))*2))
}
```

```{r ExportPopAlleleFrequencies}
# For the dataset with MAF
list_geno$list_withmaf %>% 
  compute_allele_freq %>% 
  saveRDS(here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData_PopAlleleFreq.rds"))

# For the dataset without MAF
list_geno$list_withoutmaf %>% 
  compute_allele_freq %>% 
  saveRDS(here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData_noMAF_PopAlleleFreq.rds"))
```


# Imputation of missing data

We impute missing data based on the most common genotype within the family.

We impute missing data in the dataset not filtered for MAF.

```{r ImputingNAbasedOnFamilies, eval=F}
# we load filtered genomic data not filtered for MAF
df <- readRDS(here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData.rds"))

# Function to calculate mode (i.e., most common value)
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Replace NA values with the mode within each family for each SNP
impdf <-  df %>%
  group_by(Family) %>%
  mutate(across(starts_with("AX"), ~replace(., is.na(.), Mode(.[!is.na(.)]))))

# To check that it worked
sum(is.na(impdf))

# We save the dataset
saveRDS(impdf, here("data/ScotsPine/GenomicData/FormattedData/ImputedFilteredGenomicData.rds"))
```

We then subset the dataset by keeping only SNPs without MAF (to get an imputed dataset without MAF).

```{r SavingImputedDatasetWithoutMAF}
impdf <- readRDS(here("data/ScotsPine/GenomicData/FormattedData/ImputedFilteredGenomicData.rds"))

# Extract SNPs filtered for MAF
snps_dfnomaf <- readRDS(here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData_noMAF.rds")) %>% rownames()

# Save dataset filtered for MAF and with imputed missing data
impdf %>% 
  dplyr::select(PopulationCode, Family, FieldCode, any_of(snps_dfnomaf)) %>% 
  saveRDS(here("data/ScotsPine/GenomicData/FormattedData/ImputedFilteredGenomicData_noMAF.rds"))
```

# Genetic relatedness coefficients

We use the genomic data not filtered for MAF and with no imputation of missing data to estimate the genetic relatedness coefficients $r_{ij}$. Assuming no inbreeding, $r_{ij}$ can be interpreted as the proportion of the genome that is shared between individuals $i$ and $j$. 

```{r EstimateGRM, eval=F}
# we load genomic data not filtered for MAF and without imputation for missing data
df <- readRDS(here("data/ScotsPine/GenomicData/FormattedData/FilteredGenomicData.rds"))

# change the dataset to a matrix
mat <- df[, -c(1:2)] %>% 
  column_to_rownames("FieldCode") %>% 
  as.matrix()

# We estimate the GRM with the VanRaden method
Gmat_VanRaden <- Gmatrix(SNPmatrix=mat, 
                         missingValue=NA, 
                         method="VanRaden")

# We save the G matrix
saveRDS(Gmat_VanRaden, here("data/ScotsPine/GenomicData/FormattedData/Gmat_VanRaden.rds"))

# viz the matrix
Gmat_VanRaden[1:10,1:10] %>% 
  as.data.frame() %>% 
  kable_mydf(boldfirstcolumn = TRUE, round_number = 4)
```

We extract the genetic relatedness coefficients for each pair of individuals. 

In the tutorial [GWAS 5: Relatedness and population structure by 
Matti Pirine (University of Helsinki)](https://www.mv.helsinki.fi/home/mjxpirin/GWAS_course/material/GWAS5.html), the authors refer to cutting points to assign pairs of individuals to a certain degree of relatedness based on their $r_{ij}$. These thresholds are "a commonly-used inference procedure of the KING software" and are based on the powers of $1/2$. We will use these thresholds to assign the pairs of individuals to a given degree of relatedness (i.e., identical, 1st degree, 2nd degree, 3rd degree or unrelated). 


```{r ExtractGeneticRelatednessCoeffs, fig.height=6, fig.width=8, warning=FALSE}
# we load the GRM
Gmat_VanRaden <- readRDS(here("data/ScotsPine/GenomicData/FormattedData/Gmat_VanRaden.rds"))

# Function to extract the genetic relatedness coefficients in a vector
extract_relatedness_coeffs_from_GRM <- function(GRM){
# Extract upper triangle of the matrix
upper_triangle <- upper.tri(GRM, diag=TRUE)

# Set lower triangle elements to NA
GRM[!upper_triangle] <- NA

# Convert the resulting matrix to a dataframe
df <- as.data.frame(as.table(GRM))

# Remove rows with NA values (optional if you want to remove NA values)
df <- na.omit(df)

# Rename the columns
names(df) <- c("Ind1", "Ind2", "r")

df
}


# Run the function on our GRM
df_r <- extract_relatedness_coeffs_from_GRM(GRM=Gmat_VanRaden) %>% arrange(r)

# Define the thresholds to separate the degrees of relatedness
KING_thresholds <- c(0.088, 0.177, 0.354, 0.707)

# We count the number of individual pairs within each degree of relatedness 
r_counts <- df_r %>%
  filter(!Ind1==Ind2) %>% # we remove the genetic relatedness coeffs calculated by comparing the same individuals
  summarize(
    identical = sum(r > KING_thresholds[[4]]),
    first_degree = sum(r <= KING_thresholds[[4]] & r > KING_thresholds[[3]]),
    second_degree = sum(r <= KING_thresholds[[3]] & r > KING_thresholds[[2]]),
    third_degree = sum(r <= KING_thresholds[[2]] & r > KING_thresholds[[1]]),
    unrelated = sum(r <= KING_thresholds[[1]])
  )

# we prepare the dataset for the plot 
dfplot <- df_r %>% 
  filter(!Ind1==Ind2) %>% # 
  filter(r>0.05) %>% # to aid visualization and speed up plotting (it was long if I keep all the pairs)
  mutate(Index=1:nrow(.))

# Define the breaks and labels for the y-scale
y_breaks <- c(0, 0.25, 0.5, 0.75, 1, KING_thresholds)
y_labels_colors <- ifelse(y_breaks %in% KING_thresholds, "orange", "black")

# Plot
ggplot(dfplot, aes(x = Index, 
                   y = r, 
                   color = cut(r, breaks = c(-Inf, KING_thresholds, Inf),
                               labels = c(paste0("Unrelated (n = ",r_counts$unrelated,")"), 
                                          paste0("3rd degree (n = ",r_counts$third_degree,")"), 
                                          paste0("2nd degree (n = ",r_counts$second_degree,")"), 
                                          paste0("1st degree (n = ",r_counts$first_degree,")"), 
                                          paste0("Identical (n = ",r_counts$identical,")"))))) +
  geom_point() +
  geom_hline(yintercept = KING_thresholds, linetype = "dashed", color = "orange") +
  labs(x = "Pairs of individuals", y = "Genetic relatedness coefficient") +
  theme_bw() +
  scale_color_manual(values = c("blue", "green", "deeppink", "purple", "yellow")) +
   scale_y_continuous(breaks = y_breaks) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, colour = y_labels_colors),
        legend.position = c(0.2,0.85),
        legend.title = element_blank())
```

In our dataset, we expect trees to be unrelated and that trees from the same family are half-siblings (with $0.177 > r_{ij} > 0.354$).

We look at the field data of the trees with higher $r_{ij}$ than expected.

```{r LoadFieldData}
# We load data with field and nursery information
fielddata <- readRDS(file=here("data/ScotsPine/formatted_CG_data.rds")) %>% 
  dplyr::select(PopulationCode,Family, FieldCode, FieldSite, Block, Nursery) %>% 
  mutate(FieldCode = as.character(FieldCode))
```

```{r FunctionShowFieldData}
# function to merge field data of the two individuals of each pair
show_fielddata <- function(r_threshold_min,r_threshold_max){
  
  subdf <-  dfplot %>% 
    filter(r>r_threshold_min) %>% 
    filter(r<r_threshold_max)
    
  lapply(c("Ind1","Ind2"), function(x) {
    subdf %>% 
      dplyr::select(any_of(x)) %>% 
      dplyr::rename(FieldCode=any_of(x)) %>% 
      left_join(fielddata, by ="FieldCode") %>% 
      set_colnames(paste0(colnames(.),"_",x))
}) %>% 
    bind_cols() %>% 
    mutate(RelatednessCoeff = subdf$r)
}
```


We first look at pairs of individuals considered to be identical (=clones), i.e. with $r_{ij}>0.707$.

```{r ShowPairsIdenticalIndividuals}
show_fielddata(r_threshold_min = KING_thresholds[[4]],
               r_threshold_max = 1.1) %>% 
    kable_mydf
```

For the eight pairs of individuals with $r_{ij}>0.707$ (i.e., individuals considered as identical = clones), individuals come from the same families but not always the same field site and nurseries.

We then look at the `r r_counts$first_degree` pairs of individuals considered to be full-siblings (i.e., with $0.354>r_{ij}>0.707$). We do not plot all the pairs but only those for which the two individuals do not belong to the same family. 

```{r ShowPairsFirstDegreeRelatedIndividuals}
show_fielddata(r_threshold_min = KING_thresholds[[3]],
               r_threshold_max = KING_thresholds[[4]]) %>% 
  filter(!Family_Ind1 == Family_Ind2) %>% 
  kable_mydf()
```

Among these pairs, only one corresponds to two individuals from two different populations. This is highly unlikely, there is probably a mistake here. 


We export the pairs of individuals with $r_{ij}>0.088$. 

```{r ExportingRelatedIndividuals}
lapply(c("Ind1","Ind2"), function(x) {
  dfplot %>% 
    filter(r>KING_thresholds[[1]]) %>% 
    dplyr::select(any_of(x)) %>% 
    dplyr::rename(FieldCode=any_of(x)) %>% 
    left_join(fielddata, by ="FieldCode") %>% 
    set_colnames(paste0(colnames(.),"_",x))
}) %>% 
  bind_cols() %>% 
  mutate(RelatednessCoeff = dfplot %>% filter(r>KING_thresholds[[1]]) %>% .$r) %>% 
  write.csv(here("data/ScotsPine/RelatedIndividuals.csv"), row.names = FALSE)
```


# SNPs with correlated genotypes

## Identifying correlated SNPs

We extract the pairs of SNPs with a correlation coefficient of 1 in the dataset with MAF.

```{r GenerateFilePairsCorrelatedSNPs, warning=F, eval=F}
# Invert the genomic matrix
tdf <- list_geno$list_withmaf$df %>% t() %>% as.data.frame() 

# Create a matrix of correlation for all SNPs
matcor <- cor(tdf, use = "pairwise.complete.obs")

# Keep only the upper triangle of the matrix and remove values in the diagonal
matcor[lower.tri(matcor,diag=T)] <- NA

# Arrange the pairs of correlated SNPs in two columns
snpcor <- matcor %>% 
  melt() %>% 
  na.omit() %>% 
  dplyr::filter(value==1) %>% 
  dplyr::select(-value) %>% 
  set_colnames(c("SNP1","SNP2"))

rm(matcor)

snp_match_1 <- read.csv(here("data/GenomicData/SnpCodesMatching.csv")) %>% 
  set_colnames(paste0(colnames(.),"_SNP1")) %>% 
  rename(SNP1 = snp_ID_SNP1)

snp_match_2 <- read.csv(here("data/GenomicData/SnpCodesMatching.csv")) %>% 
  set_colnames(paste0(colnames(.),"_SNP2")) %>% 
  rename(SNP2 = snp_ID_SNP2)
  
snpcor <- snpcor %>% 
  left_join(snp_match_1, by = "SNP1") %>% 
  left_join(snp_match_2, by = "SNP2")

# save file (file sent to Santi 14/02/2023)
# snpcor %>% write_csv(here("data/GenomicData/CorrelatedSNPs.csv"),append=FALSE) 
```

```{r LoadCorrelatedSNPsDataset, eval=F}
# we load the dataset of pairs of SNPs with a correlation coeff of 1 that I sent to Santi the 14/02/2023
snpcor <- read.csv(here("data/GenomicData/CorrelatedSNPs.csv"))
```


# SNPs positions

File 'map.txt'. 


```{r SNPpositionFile}
# Load the raw genomic data:
map_snp <- read_table(here("data/ScotsPine/GenomicData/map.txt"),show_col_types=F)

map_snp[1:10,] %>% kable_mydf(boldfirstcolumn = T, font_size = 10)
```

<br>

Meaning of the columns (information provided by Annika Perry):

  - **SNP** = SNP id as provided by Thermo

  - **LG** = linkage group

  - **MALE_POS**; **FEMALE_POS**; **TAB_CONTIG**; **TAB_POS** = columns provided by Tanja Pyhäjärvi - should match the *Pinus tabuliformis* genome

  - **AssignedChromosome** = the chromosome that the SNP has been assigned to – either directly (by matching to the *P. tabuliformis* genome) or indirectly (most LG are associated with a single chromosome, so if Tanja’s file had information on the LG but not the chromosome, Annika inferred that it belonged to the chromosome that the LG most frequently mapped to. If this was the case, I assigned a position for the SNP arbitrarily starting from 1 – see the next columns. If there was no information on LG then I assigned to chromosome ‘13’)

  - **AssignedPosition** = as above – most positions were assigned by mapping to the *P. tabuliformis* genome, if information on position was no available Annika added information arbitrarily

  - **InferredChromosome** = indicates whether the chromosome was assigned through mapping to *P. tabuliformis* (NO) or inferred by Annika (YES)

  - **InferredPosition** = indicates whether the position was assigned through mapping to *P. tabuliformis* (NO) or inferred by Annika (YES)
  
**To keep in mind**: if two SNPs belong to chromosome 13, we cannot consider that they are on the same chromosome.

```{r CheckingNumberNAsMAPfile}
sapply(map_snp, function(x) sum(is.na(x)))
```

We look at the number of SNPs in each linkage group.

```{r NumberSNPsLG}
lapply(list_geno,function(x){
  
  map_snp %>% 
    filter(SNP %in% colnames(x[,-c(1:3)])) %>% 
    count(LG) 
  
}) %>% 
  setNames(c("Dataset with MAF","Dataset without MAF")) %>% 
  bind_rows(.id="Dataset") %>% 
  pivot_wider(names_from = "Dataset", values_from = "n") %>% 
  kable_mydf()
```

For each linkage group, we look at the number of SNPs assigned to each chromosome. For most linkage groups, SNPs are mostly assigned to one chromosome, except for the linkage groups 2 and 3 for which the SNPs are almost equally well assigned to chromosome 1 and 3.

```{r NumberSNPsChromosome}
lapply(list_geno,function(x){
  
 map_snp %>% 
    filter(SNP %in% colnames(x[,-c(1:3)])) %>% 
    count(LG, AssignedChromosome)
  
}) %>% 
  setNames(c("Dataset with MAF","Dataset without MAF")) %>% 
  bind_rows(.id="Dataset") %>% 
  pivot_wider(names_from = "Dataset", values_from = "n") %>% 
  kable_mydf()
```

We look at the total number of SNPs for which the chromosome was inferred.

```{r NumberSNPsInferredChromosome}
lapply(list_geno,function(x){
  
  map_snp %>% 
    filter(SNP %in% colnames(x[,-c(1:3)])) %>% 
    count(InferredChromosome) 
  
}) %>% setNames(c("Dataset with MAF","Dataset without MAF")) %>% 
  bind_rows(.id="Dataset") %>% 
  pivot_wider(names_from = "Dataset", values_from = "n") %>% 
  kable_mydf()
```

We look at the total number of SNPs assigned to each chromosome. SNPs were assigned to chromosome 13 when no information on LG was available. 

```{r NumberSNPsAssignedChromosome}
lapply(list_geno,function(x){
  
  map_snp %>% 
    filter(SNP %in% colnames(x[,-c(1:3)])) %>% 
    count(AssignedChromosome) 
  
}) %>% setNames(c("Dataset with MAF","Dataset without MAF")) %>% 
  bind_rows(.id="Dataset") %>% 
  pivot_wider(names_from = "Dataset", values_from = "n") %>% 
  kable_mydf()
```

We look only at SNPs without information on LG:

```{r}
lapply(list_geno,function(x){
  
 map_snp %>% 
    filter(SNP %in% colnames(x[,-c(1:3)])&is.na(LG)) %>% 
    count(TAB_CONTIG,AssignedChromosome)
  
}) %>% 
  setNames(c("Dataset with MAF","Dataset without MAF")) %>% 
  bind_rows(.id="Dataset") %>% 
  pivot_wider(names_from = "Dataset", values_from = "n") %>% 
  kable_mydf()
```

If there is some information about the chromosome in the column `TAB_CONTIG` (although no information on LG), the value in the `AssignedChromosome` column correspond to the chromosome in the column `TAB_CONTIG`.

We look at the number of SNPs for each combination of `LG`, `TAB_CONTIG`and `AssignedChromosome`.

```{r NumberSNPsCombinationLGContigAssignedChromosome}
lapply(list_geno,function(x){
  
 map_snp %>% 
    filter(SNP %in% colnames(x[,-c(1:3)])) %>% 
    count(LG,TAB_CONTIG,AssignedChromosome)
  
}) %>% setNames(c("Dataset with MAF","Dataset without MAF")) %>% 
  bind_rows(.id="Dataset") %>% 
  pivot_wider(names_from = "Dataset", values_from = "n") %>% 
  kable_mydf()
```