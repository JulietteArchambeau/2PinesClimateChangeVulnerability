---
title: "Estimating phenotypic plasticity of Scots pine populations"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 11px
}
</style>

```{r setup, include=F}
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))
knitr::opts_chunk$set(cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(tidyverse)
library(here)
library(magrittr)
library(corrplot)
library(readxl)
library(rstan)
library(tidybayes)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

theme_set(theme_bw(base_size = 20))

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
source(here("scripts/functions/make_spatialpoints_map.R"))
```

# Data information

All info in @beaton2022phenotypic.

Seed from **ten trees** from each of **21 native Scottish *P. sylvestris* populations** were collected in March 2007. Populations were chosen to represent the species native range in Scotland and to include three populations from each of the seven seed zones. 

Trees from the same population can be considered unrelated (see sampling strategy). Seedlings from the same mother tree are described as a family and are assumed to be half-siblings.

After growing in one of three nurseries (NW, NG and NE), trees were transplanted to one of three field sites in 2012: 
  
  - **Yair** in the Scottish Borders (field site in the south of Scotland: **FS**, latitude 55.603625, longitude -2.893025). All trees transplanted to FS were raised in the NG.
  
  - **Glensaugh** (field site in the east of Scotland: **FE**, latitude 56.893567, longitude -2.535736). All but four of the trees transplanted to FE were raised locally in the NE (the remainder were grown in NG).
  
  - **Inverewe** (field site in the west of Scotland: **FW**, latitude 57.775714, longitude -5.597181). FW contains cohorts of trees raised in each of the three nurseries as follows: 290 were grown locally in the NW; 132 were grown in the NG; and 82 were grown in the NE.


At each site, trees were planted in randomised blocks at 3 m x 3 m spacing. There are **four randomised blocks in both FS and FE** and **three in FW**. 

There are **168 families** in total. Each block comprised one individual from each of eight (of the 10 sampled) families per 21 populations (168 trees). 

<span style="color: red;">Although most families (N = 159) were represented at each of the three sites, families with insufficient trees (N = 9) were replaced in one site (FS) with a different family from the same population.</span>

<span style="color: darkgreen;">**Important points for the phenotypic plasticity analyses**</span>

  - strong effect of nurseries on the phenotypes
  
  - potential effects of blocks
  
  - In FS, some families are not the same as in FE and FW.
  
  - FE is the site with the harshest climate (i.e. coldest site with the shortest growing season length) and FW the most beneficial climate, i.e. warmer and wetter and with more growing degree days per year and a much longer season length than the two other sites  [see Table 2 of @beaton2022phenotypic]. 


# Relative distance plasticity index (RDPI)

@valladares2006quantitative proposes to quantify phenotypic plasticity based on phenotypic distances among individuals of a given species (in our study, population) exposed to different environments (in our study, planted in different common gardens), which is summarized in a relative distance plasticity index (RDPI) that allows for statistical comparisons of phenotypic plasticity between species (in our study, populations). 


For a given trait, the relative distance plasticity index $RDPI_p$ for a given population $p$ can be calculated as follows:

$$RDPI_p = \frac{\sum_{n=1}^N{\frac{x_{ij}-x_{i'j'}}{x_{ij}+x_{i'j'}}}}{N}$$

where $N$ is the number of pairwise comparisons among individuals of the same population but from different common gardens. $x_{ij}$ and $x_{i'j'}$ are the phenotypic values of individual $j$ and $j'$ in common gardens $i$ and $i’$, with $ii’$. As such, the phenotypic plasticity of a population for a given trait corresponds to the sum of the relative phenotypic distances for all pairs of individuals of the population grown in different common gardens.


<span style="color: orange;">**Comment:**</span> Note that RDPI may also be calculated at the family level (instead of the population level as above) and then be averaged for each population. However, as some families in FS are not the as in FE and FW, I thought that calculating the RDPI indexes directly at the population level would allow to consider all families (not having to remove some). But this is point I will be happy to discuss! 

```{r LoadCGdata, eval=T}
data <- read_excel(here("data/Field.xlsx"), na = "NA")
```

We calculate the RDPI for:

  - height measurements
  
  - the duration of bud burst
  
  - the number of days to reach of stage 4, 5 or 6 of budburst.
  

We check the number of NAs for the different traits:

```{r CheckNAheightMeasurments}
data %>% dplyr::select(contains("HA")) %>% sapply(function(x) sum(is.na(x)))
data %>% dplyr::select(contains("BD")) %>% sapply(function(x) sum(is.na(x)))
data %>% dplyr::select(contains("BT")) %>% sapply(function(x) sum(is.na(x)))
```


```{r CalculateRDPI, eval=F}
pop_codes <- unique(data$PopulationCode) # population codes
site_codes <- unique(data$FieldSite) # field site codes
site_comb <- combn(site_codes,2)
calc_rel_dist <- function(x){abs(x[1]-x[2])/(x[1]+x[2])}

list_traits <- list(heights = data %>% dplyr::select(contains("HA")) %>% colnames(), # height measurements
                    duration_budburst = data %>% dplyr::select(contains("BD")) %>% colnames(), # duration of bud burst
                    timing_budburst = data %>% dplyr::select(contains("BT")) %>% colnames()) # time taken to reach budburst stages

lapply(list_traits, function(traits) {
  
  lapply(traits, function(trait){

  lapply(pop_codes, function(pop){
  
  subpop <- data %>%
    drop_na(any_of(trait)) %>% 
    dplyr::filter(PopulationCode %in% pop)
  
  n_pop <- nrow(subpop) # nb of individuals in the population

 rel_dist <- lapply(1:dim(site_comb)[[2]], function(nb_comb){
 
    subsite1 <- subpop %>% dplyr::filter(FieldSite %in% site_comb[1,nb_comb])
    subsite2 <- subpop %>% dplyr::filter(FieldSite %in% site_comb[2,nb_comb])
    
    
    lapply(1:nrow(subsite1), function(x) {
      
      
      rbind(subsite1[x,trait],subsite2[,trait]) %>% 
        pull() %>% 
        combn(2, calc_rel_dist) %>% 
        .[1:nrow(subsite2)] %>% 
        as.numeric()
      
      }) %>% unlist()
    
    }) %>% unlist()
 
 N <- length(rel_dist)
 
sum(rel_dist)/N
 
 
 }) %>% 
    setNames(pop_codes) %>% 
    as_tibble() %>% 
    pivot_longer(everything(), names_to = "PopulationCode", values_to = "RDPI") %>% 
    mutate(Trait=trait)
  
  }) %>% bind_rows()

  
}) %>% saveRDS(file=here("outputs/PhenotypicPlasticity/RDPI.rds"))
```

## Mapping some of the RDPI indexes

RDPI for **height** in 2014 (`HA14`) and 2020 (`HA20`) for each population:

```{r MappingRDPIheights, fig.height=8,fig.width=8, warning=F, results="hide"}
lapply(c("HA14","HA20"), function(trait){

readRDS(file=here("outputs/PhenotypicPlasticity/RDPI.rds"))$heights %>% 
  filter(Trait == trait) %>% 
  make_spatialpoints_map(var="RDPI",
                         ggtitle=trait)})
```

RDPI for the **duration of bud burst** in 2015 (`BD15`) and in 2019 (`BD19`) for each population:

```{r MappingRDPIdurationbudburst, fig.height=8,fig.width=8, warning=F, results="hide"}
lapply(c("BD15","BD19"), function(trait){

readRDS(file=here("outputs/PhenotypicPlasticity/RDPI.rds"))$duration_budburst %>% 
  filter(Trait == trait) %>% 
  make_spatialpoints_map(var="RDPI",
                         ggtitle=trait)})
```

RDPI for the **time taken to reach stage 4, 5 and 6** in 2019 for each population:

```{r MappingRDPItimingbudburst, fig.height=8,fig.width=8, warning=F, results="hide"}
lapply(c("BT19_4","BT19_5","BT19_6"), function(trait){

readRDS(file=here("outputs/PhenotypicPlasticity/RDPI.rds"))$timing_budburst %>% 
  filter(Trait == trait) %>% 
  make_spatialpoints_map(var="RDPI",
                         ggtitle=trait)})
```

## Correlation among RDPI indexes

```{r CorrelationPlotsRDPIAcrossClassOfTraits, fig.height=7,fig.width=7, results='hide'}
list_titles <- list(list("heights","height"),
                    list("duration_budburst","the duration of budburst"),
                    list("timing_budburst","the time taken to reach budburst stages"))

lapply(list_titles, function(x){
  
  readRDS(file=here("outputs/PhenotypicPlasticity/RDPI.rds"))[[x[[1]]]] %>% 
  pivot_wider(values_from = RDPI, names_from = Trait) %>% 
  dplyr::select(-PopulationCode) %>% 
  cor() %>% 
  corrplot(method = 'number',
           type = 'lower', diag = FALSE,
           title=paste0("Correlation among RDPI for ",x[[2]]),
           mar=c(0,0,2,0),
           number.cex=0.9,tl.cex=0.9)
  })
```


<span style="color: orange;">Interpretation</span>

Strong correlation of the RDPI indexes among years for height, which is expected as height at year $t$ is a function of height at year $t-1$, which is not the case of phenology variables such as the duration of bud burst and the time taken to reach budburst stages.

We may have expected higher correlations of the RDPI indexes calculated for a given year, e.g. correlation among the RDPI indexes calculated for the time taken to reach budburst stage 4, 5 or 6 of the same year, but surprisingly, the correlations are not very high.

The correlations are even negative when the RDPI indexes are calculated for phenology variables across different years.

We can also look at the correlation among the RDPI indexes calculated for the different traits (see the correlation graph below) but correlations are also very low across traits:

```{r CorrelationPlotsRDPIAllTraits, fig.height=9,fig.width=9, results='hide'}
 readRDS(file=here("outputs/PhenotypicPlasticity/RDPI.rds")) %>%
  bind_rows() %>% 
  pivot_wider(values_from = RDPI, names_from = Trait) %>% 
  dplyr::select(-PopulationCode) %>% 
  cor() %>% 
  corrplot(method = 'number',
           type = 'lower', diag = FALSE,
           title=paste0("Correlation among RDPI for all traits"),
           mar=c(0,0,2,0),
           number.cex=0.6,tl.cex=0.9)
```


# To discuss!
 
The RDPI approach is really straightforward and easy to calculate but:

  - the effect of the nurseries on the phenotypes is not accounted for.
  
  - no measure of uncertainty around RDPI estimates.
  
Also, how to know which plasticity responses are adaptive or not? 

And how to determine which populations are the most plastic? Indeed, depending on the traits, the ranking of the populations is very different.. Should we combine the different traits? But if yes, how? It seems that for height we can use only one RDPI index (as they are very similar across years) but for the phenology variables, the choice of the year and even the stage considered (4, 5 or 6) for the timing of budburst will be very important. 

<!-- With only three common gardens, we cannot estimate some reaction norms that will inform us on the optimal climate of each population (and so whether we can consider that the populations the closest to each common garden show the optimal phenotypic responses). -->
  
# Accounting for the nursery effects


```{r LoadNurseryDataPerry2022, message=F}
# Dataset in Beaton et al. (2022)
nursery_data <- read_delim(here("data/nurserytraits.txt"), show_col_types = FALSE) %>% 
  dplyr::select(PopulationCode, Family,Nursery,FieldCode) %>% 
  drop_na(FieldCode)

# data <- data %>% left_join(nursery_data, by=c("FieldCode","PopulationCode","Family")) 
```

In the nursery dataset from @perry2022nurserydata, `r nrow(nursery_data)` trees have a field code. 

02/06/2023 - Annika found the field code of the trees that had none in @perry2022nurserydata, here is the updated file:

```{r LoadUpdatedNurseryData}
# Dataset updated by Annika - 02/06/2023
nursery_data <- read_excel(here("data/SPnurseries_updatedByAnnika02062023.xlsx")) %>% 
  dplyr::rename(FieldCode=Tag)
```

We can then match the nursery and common garden data using the the field code:

```{r MergeNurseryData}
data <- data %>% left_join(nursery_data, by=c("FieldCode")) 
```



## Mathematical model


We model each trait $y$ such as:

\begin{equation}
\begin{aligned}
y_{sbpfnr} & \sim  \mathcal{N}(\mu_{sbpfn},\sigma^{2}_{r})\\[3pt]
\mu_{bpc} & =  \beta_{0} +  S_{s} +  B_{b} + P_{p} + F_{f} + N_{n} +  S_{s} \times N_{n} + S_{s} \times F_{f} \\[3pt]
\beta_{0} & \sim \mathcal{N}(\mu_{y},2)\\[3pt]
\begin{bmatrix} S_{s} \\ B_{b} \\ P_{p} \\ F_{f} \\ N_{n} \\ S_{s} \times F_{f} \\ S_{s} \times N_{n} \end{bmatrix} 
    & \sim \mathcal{N}\left(0,
\begin{bmatrix}
\sigma^{2}_{S}\\[3pt]
\sigma^{2}_{B}\\[3pt]
\sigma^{2}_{P}\\[3pt]
\sigma^{2}_{F}\\[3pt]
\sigma^{2}_{N}\\[3pt]
\sigma^{2}_{S \times F}\\[3pt]
\sigma^{2}_{S \times N}\\[3pt]
\end{bmatrix}
\right)\\
\end{aligned}
\end{equation}

$\beta_{0}$ is the global intercept.
$S_{s}$ are the site intercepts with a variance $\sigma^{2}_{S}$.
$B_{b}$ are the block intercepts with a variance $\sigma^{2}_{B}$.
$P_{p}$ are the population intercepts with a variance $\sigma^{2}_{P}$.
$F_{f}$ are the family intercepts with a variance $\sigma^{2}_{F}$.
$N_{n}$ are the nursery intercepts with a variance $\sigma^{2}_{N}$.
$\sigma^{2}_{S \times F}$ is the variance of the interaction among the sites and families, that is the G$\times$E variance.
$\sigma^{2}_{S \times N}$ is the variance of the interaction among the sites and nurseries.
$\sigma^{2}_{r}$ is the residual variance.


Partitioning of the total variance $\sigma_{tot}^{2}$:

\begin{equation}
\begin{aligned}
\sigma_{tot}^{2} & = \sigma_{r}^{2} + \sigma_{S}^{2} + \sigma_{B}^{2} + \sigma_{P}^{2} + \sigma_{F}^{2} + \sigma_{N}^{2} + \sigma_{S \times F}^{2} + \sigma_{S \times N}^{2}\\[3pt]
\sigma_{r} & = \sigma_{tot} \times \sqrt(\pi_{r})\\[3pt]
\sigma_{S} & = \sigma_{tot} \times \sqrt(\pi_{S})\\[3pt]
\sigma_{B} & = \sigma_{tot} \times \sqrt(\pi_{B})\\[3pt]
\sigma_{P} & = \sigma_{tot} \times \sqrt(\pi_{P})\\[3pt]
\sigma_{F} & = \sigma_{tot} \times \sqrt(\pi_{F})\\[3pt]
\sigma_{N} & = \sigma_{tot} \times \sqrt(\pi_{N})\\[3pt]
\sigma_{S \times F} & = \sigma_{tot} \times \sqrt(\pi_{S \times F})\\[3pt]
\sigma_{S \times N} & = \sigma_{tot} \times \sqrt(\pi_{S \times N})\\[3pt]
\sigma_{tot} & \sim \mathcal{S}^{*}(0,1,3)
\end{aligned}
\end{equation}

with $\sum_{l}^{8}\pi_{l}=1$.

Here is the Stan code of the model:

```{r Stancode}
model <- stan_model(here("scripts/stan_models/StandardQuantGenModel.stan"))
model
```

Options for the Stan models:

```{r ModelOptions}
# Sampling in Bayesian models
n_chains <- 4 # number of chains (MCMC)
n_iter <- 2500 # number of iterations
n_warm <- 1250 # number of iterations in the warm-up phase
n_thin <- 1 # thinning interval
save_warmup <- FALSE 

# Credible intervals
point_est <-"median"
conf_level <- 0.95
```


## Height in 2020

We run the model for height in 2020.

```{r Stanlist}
trait <- "HA20"

subdata <- data %>% 
  dplyr::select(FieldSite,Block,PopulationCode,Family,Nursery,all_of(trait)) %>% 
  mutate(site_fam = paste0(FieldSite,"_",Family),
         site_nurs = paste0(FieldSite,"_",Nursery),
         Block = paste0(FieldSite,"_",Block)) %>% 
  drop_na()


# Building the stanlist ourselves
# ===============================

# stanlist <- list(N=nrow(subdata), 
#                  y=subdata[[trait]],
#                  nsite = length(unique(subdata$FieldSite)),
#                  nblock = length(unique(subdata$Block)),
#                  npop = length(unique(subdata$PopulationCode)),
#                  nfam = length(unique(subdata$Family)),
#                  nnurs = length(unique(subdata$Nursery)),
#                  nsite_fam = length(unique(subdata$site_fam)),
#                  nsite_nurs = length(unique(subdata$site_nurs)),
#                  site = as.numeric(as.factor(subdata$FieldSite)),
#                  bloc = as.numeric(as.factor(subdata$Block)),
#                  pop = as.numeric(as.factor(subdata$PopulationCode)),
#                  fam = as.numeric(as.factor(subdata$Family)),
#                  nurs = as.numeric(as.factor(subdata$Nursery)),
#                  site_fam = as.numeric(as.factor(subdata$site_fam)),
#                  site_nurs = as.numeric(as.factor(subdata$site_nurs)))



# Using compose_data to build the stanlist
# ========================================

subdata <- subdata %>% 
  dplyr::rename(site=FieldSite,
                bloc=Block,
                pop=PopulationCode,
                fam=Family,
                nurs=Nursery,
                y=any_of(trait))
```


```{r RunningStanModel,eval=F}
stanfit <- sampling(model,
                    data = compose_data(subdata),
                    pars=c("beta0", "pi", "R_squared", "h2",
                           "alpha_site","alpha_block","alpha_pop","alpha_fam","alpha_nurs","alpha_site_fam","alpha_site_nurs",
                           "sigma2_r","sigma2_site","sigma2_block","sigma2_pop","sigma2_fam","sigma2_nurs","sigma2_site_fam","sigma2_site_nurs","sigma2_tot"),
                    iter = n_iter, 
                    chains = n_chains, 
                    cores = n_chains,
                    save_warmup = save_warmup,
                    thin=n_thin)

stanfit %>% saveRDS(file=here(paste0("outputs/VariancePartitioning/",trait,"_VarPartModel.rds")))
```


> Variance partitioning

```{r PlotVarPart, fig.height=9,fig.width=9}
mod_factors <- rev(c("Residuals","Sites","Blocks","Populations","Families","Nurseries","Sites*Families","Sites*Nurseries"))

readRDS(file=here(paste0("outputs/VariancePartitioning/",trait,"_VarPartModel.rds"))) %>% 
    broom.mixed::tidyMCMC(pars=("pi"),
                droppars = NULL, estimate.method = point_est, ess = F, rhat = F, conf.int = T,conf.level = conf_level) %>% 
    mutate(prop_var=mod_factors) %>% 
    mutate(prop_var=factor(mod_factors,
                           levels=mod_factors)) %>%
  ggplot(aes(y = prop_var, x = estimate, xmin = conf.low, xmax = conf.high)) +
  geom_pointinterval(position = position_dodge(width = .8),point_size=3,alpha=0.6,size=5) +
  ylab("") +
  xlab("Proportion of variance explained") +
  labs(color = "Potential drivers") +
  theme(axis.text = element_text(size=25),
        panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))

```

> Intercepts Sites * Nurseries

```{r AlphaSiteNursPlots, fig.height=9,fig.width=9, warning=F}
# Plotting intervals with densities
# =================================
stanfit <- readRDS(file=here(paste0("outputs/VariancePartitioning/",trait,"_VarPartModel.rds")))

stanfit %<>% recover_types(subdata)

stanfit %>% 
  spread_draws(alpha_site_nurs[site_nurs]) %>%
  ggplot(aes(y = site_nurs, x = alpha_site_nurs)) +
  stat_halfeye() +
  ylab("") +
  xlab("") +
  labs(color = "Potential drivers") +
  theme(axis.text = element_text(size=25),
        panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))

# Plotting point summaries and intervals
# ======================================

# readRDS(file=here(paste0("outputs/VariancePartitioning/",trait,"_VarPartModel.rds"))) %>% 
#     broom.mixed::tidyMCMC(pars=("alpha_site_nurs"),
#                 droppars = NULL, estimate.method = point_est, ess = F, rhat = F, conf.int = T,conf.level = conf_level) %>% 
#   mutate(param = levels(as.factor(subdata$site_nurs))) %>% 
#   ggplot(aes(y = param, x = estimate, xmin = conf.low, xmax = conf.high)) +
#   geom_pointinterval(position = position_dodge(width = .8),point_size=3,alpha=0.6,size=5) +
#   ylab("") +
#   xlab("") +
#   labs(color = "Potential drivers") +
#   theme(axis.text = element_text(size=25),
#         panel.grid.minor.y=element_blank(),
#         panel.grid.major.y=element_blank())  +
#     guides(color=guide_legend(ncol=1))
```

For height in 2020, the nursery has an effect on height variation, with is different across sites. So we may want to calculate the RDPI indexes after having removed the nursery effect.