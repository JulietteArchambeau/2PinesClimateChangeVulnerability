---
title: "Evolvability, narrow-sense heritability and within-family variance of height"
subtitle: "Height in 2014 and 2020"
author: "Juliette Archambeau"
date: last-modified
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 11px
}
</style>

```{r setup, include=F}
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))
knitr::opts_chunk$set(cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(tidyverse)
library(here)
library(magrittr)
library(corrplot)
library(readxl)
library(rstan)
library(tidybayes)

library(bayesplot)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

theme_set(theme_bw(base_size = 20))

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
source(here("scripts/functions/make_spatialpoints_map.R"))
```

# Introduction

**Goal:** Comparing the adaptive potential of the populations. 

For that, we estimate the narrow-sense heritability, evolvability and within-population (i.e. family) variance of the populations for height (measured in 2014 and 2020). 

We estimate these genetic parameters:
  
  - at the species-level (i.e. one estimate for all populations).
  
  - at the population-level with population-specific models (i.e. one model per population).
  
  - at the population-level with one model for all populations (hereafter referred as 'full model'), and based on @archambeauReducedWithinpopulationQuantitative2023. 


As heritability and evolvability are specific to the environment, the models are fitted in each common garden separately. We fit models that do not account for the nursery effect for the two common gardens in which trees come from the same nursery: the sites of **Yair (FS)** in the Scottish borders (in which all trees come from NG) and **Glensaugh (FE)** in which all trees come from NE (except four trees that come from NG and that we remove for the analyses).
  
We fit models that do account for the nursery effect in the common garden in which trees come from different nurseries: **Inverewe (FW)**, which contains cohorts of trees raised in each of the three nurseries as follows: 290 grown locally in the NW; 132 grown in the NG; and 82 grown in the NE.

## Heritability calculation

In family-based progeny trials, we assume that the seedlings from each maternal tree are half-siblings (i.e. same mother but each with a different father).

The coefficient of relationship of half-siblings is $r = 1/4$, and therefore $\sigma^2_A = 4\sigma^2_{family}$.

The narrow-sense heritability is equal to $h^2 = \frac{\sigma^2_{A}}{\sigma^2_{P}} = \frac{4\sigma^2_{family}}{\sigma^2_{P}}$ where $\sigma^2_{A}$ is the additive genetic variance, $\sigma^2_{P}$ is the phenotypic variance and $\sigma^2_{f}$ is the family variance. 

What is annoying is that when calculating $h^2$ based on family-based progeny trials (without genomic information), people do not include the same terms in the determinant. See the [*Short Note: On Estimating Heritability according to practical applications* by Coterill in 1986](https://www.thuenen.de/media/institute/fg/PDF/Silvae_Genetica/1987/Vol._36_Heft_1/36_1_46.pdf)

In our case, we will estimate $h^2$ as follows:

$$h^2 = \frac{4\sigma^2_{family}}{\sigma^2_{family} + \sigma^2_r}$$

And evolvability as follows:

$$I = \frac{4\sigma^2_{family}}{\text{mean(y)}^2}$$
When looking at the genomic data (`FormattingScotsPineGenomicData.qmd` report), we found that some pairs of individuals expected to be half-sibs showed a coefficient of relationships higher than 0.7 (i.e. clones) or between 0.354 and 0.707 (i.e. full-sibs). To account for that, we may want to use the "true" relationship coefficients between individuals, that we can get from the genomic data, i.e. use a genomic relationship matrix to estimate $h^2$. 

<!-- Another way of doing would be to do like this paper: Use of molecular markers for estimating breeding parameters: a case study in a Pinus pinaster Ait. progeny trial. Gaspar et al. 2009. https://link.springer.com/article/10.1007/s11295-009-0213-1 -->
<!-- Based on this paper: https://www.thuenen.de/media/institute/fg/PDF/Silvae_Genetica/1974/Vol._23_Heft_5/23_5_149.pdf -->


## Height data

For details on the data, see the report `ExploringFormattingCGdata.qmd`.

```{r LoadCGData}
# we load the phenotypic data
data <- readRDS(file=here("data/ScotsPine/formatted_CG_data.rds"))

sites <- c("FE" = "Glensaugh (FE)", "FW" = "Inverewe (FW)", "FS" = "Yair (FS)")
```

How many NAs for height measurements?

```{r HeightNAs}
data %>% dplyr::select(contains("HA")) %>% sapply(function(x) sum(is.na(x)))
```

We analyse height in 2014 and 2020.

```{r ChosenHeights}
ht <- list(codes = c("HA14","HA20"),
           names = c("Height in 2014","Height in 2020"),
           colors= c("chartreuse","chartreuse4"))

names(ht$names) <- ht$codes
```

We keep only the colums of interest and we remove the four trees in FE that belong to the NG nursery:

```{r SubsetHeights}
subdata <- data %>% 
  dplyr::select(FieldSite,Block,PopulationCode,Family,Nursery,all_of(ht$codes)) %>% 
  dplyr::rename(site=FieldSite,
                bloc=Block,
                pop=PopulationCode,
                fam=Family,
                nurs=Nursery) %>% 
  filter(!(site=="FE" & nurs =="NG")) %>% # we remove the four trees that come from the nursery NG in the field site FE
  pivot_longer(contains("HA"), names_to = "y_names", values_to = "y_values")
```


```{r HeigthDistributionCG, fig.width=10, fig.height=6, warning=F}
subdata %>%
  drop_na(y_values) %>% 
  ggplot(aes(x=y_values)) +  
    geom_histogram(aes(y=after_stat(density), colour=y_names,fill=y_names),bins = 50, alpha = 0.4) +
    geom_density(aes(colour=y_names),alpha=.2,fill="white") +
    facet_wrap(~site,scales="free", labeller = labeller(site = sites)) + 
    scale_fill_manual(name = "Trait", values = ht$colors, labels = ht$names) +
    scale_color_manual(name = "Trait", values = ht$colors, labels = ht$names) +
    ylab("Density") + xlab("Height values") +
    theme_bw() +
    theme(legend.position = c(0.9,0.9))
```


## Stan model options

Options for the Stan models across the document:

```{r ModelOptions}
# Sampling in Bayesian models
n_chains <- 4 # number of chains (MCMC)
n_iter <- 2500 # number of iterations
n_warm <- 1250 # number of iterations in the warm-up phase
n_thin <- 1 # thinning interval
save_warmup <- FALSE 

# Credible intervals
conf_level <- 0.95
```

# Species-level

In this section, we estimate evolvability ($I$) and narrow-sense heritability ($h^2$) at the species level, i.e. one value for all populations.

## Model equation


Here is the mathematical model for a common garden with different nurseries. The mathematical model for a common garden with trees coming from one nursery is the same, without the nursery intercepts.

We model each trait $y$ such as:

\begin{equation}
\begin{aligned}
y_{bpfnr} & \sim  \mathcal{N}(\mu_{bpfn},\sigma^{2}_{r})\\[3pt]
\mu_{bpc} & =  \beta_{0} +  B_{b} + P_{p} + F_{f} + N_{n} \\[3pt]
\beta_{0} & \sim \mathcal{N}(\mu_{y},2)\\[3pt]
\begin{bmatrix} B_{b} \\ P_{p} \\ F_{f} \\ N_{n} \end{bmatrix} 
    & \sim \mathcal{N}\left(0,
\begin{bmatrix}
\sigma^{2}_{B}\\[3pt]
\sigma^{2}_{P}\\[3pt]
\sigma^{2}_{F}\\[3pt]
\sigma^{2}_{N}\\[3pt]
\end{bmatrix}
\right)\\
\end{aligned}
\end{equation}

$\beta_{0}$ is the global intercept.
$B_{b}$ are the block intercepts with a variance $\sigma^{2}_{B}$.
$P_{p}$ are the population intercepts with a variance $\sigma^{2}_{P}$.
$F_{f}$ are the family intercepts with a variance $\sigma^{2}_{F}$.
$N_{n}$ are the nursery intercepts with a variance $\sigma^{2}_{N}$.
$\sigma^{2}_{r}$ is the residual variance.


Partitioning of the total variance $\sigma_{tot}^{2}$:

\begin{equation}
\begin{aligned}
\sigma_{tot}^{2} & = \sigma_{r}^{2} + \sigma_{B}^{2} + \sigma_{P}^{2} + \sigma_{F}^{2} + \sigma_{N}^{2} \\[3pt]
\sigma_{r} & = \sigma_{tot} \times \sqrt(\pi_{r})\\[3pt]
\sigma_{B} & = \sigma_{tot} \times \sqrt(\pi_{B})\\[3pt]
\sigma_{P} & = \sigma_{tot} \times \sqrt(\pi_{P})\\[3pt]
\sigma_{F} & = \sigma_{tot} \times \sqrt(\pi_{F})\\[3pt]
\sigma_{N} & = \sigma_{tot} \times \sqrt(\pi_{N})\\[3pt]
\sigma_{tot} & \sim \mathcal{S}^{*}(0,1,3)
\end{aligned}
\end{equation}

with $\sum_{l}^{5}\pi_{l}=1$.

> Estimation of $h^2$ (narrow-sense heritability) and $I$ (evolvability). 

We assume that the seedlings from each maternal tree are half-siblings (i.e. same mother but each with a different father), so $\sigma^2_A = 4\sigma^2_{family}$, and so $h^2 = \frac{4\sigma^2_{family}}{\sigma^2_{family} + \sigma^2_r}$ and $I = \frac{4\sigma^2_{family}}{\text{mean(y)}^2}$.

Comment: in some papers, I've seen $h^2 = \frac{4\sigma^2_{family}}{\sigma^2_{family} + \sigma^2_{population} + \sigma^2_r}$. Which $h^2$ estimation should we use?


## Stan code

```{r StancodeSpeciesLevelModels, cache=T}
model_different_nurseries <- stan_model(here("scripts/stan_models/Evolvability_M1_DifferentNurseries.stan"))
model_one_nursery <- stan_model(here("scripts/stan_models/Evolvability_M1_OneNursery.stan"))
model_different_nurseries
```



## Running the models

```{r RuningSpeciesLevelModel, eval=F}
lapply(ht$codes, function(ht_i){
  lapply(names(sites), function(site_i){
  
  subsubdata <- subdata %>% 
    filter(site==site_i & y_names == ht_i) %>% 
    drop_na(y_values) %>% 
    dplyr::select(-y_names) %>% 
    dplyr::rename(y=y_values)
  
  if(site_i %in% c("FE","FS")){ 
    model <- model_one_nursery
    pars <- c("beta0", "pi", "R_squared", "h2","I",
              "alpha_block","alpha_pop","alpha_fam",
              "sigma2_r","sigma2_block","sigma2_pop","sigma2_fam","sigma2_tot")
  } else if(site_i == "FW"){
    model <- model_different_nurseries
    pars <- c("beta0", "pi", "R_squared", "h2","I",
              "alpha_block","alpha_pop","alpha_fam","alpha_nurs",
              "sigma2_r","sigma2_block","sigma2_pop","sigma2_fam","sigma2_nurs","sigma2_tot")
      
    }
  
  stanfit <- sampling(model,
                    data = compose_data(subsubdata),
                    pars=pars,
                    iter = n_iter, 
                    chains = n_chains, 
                    cores = n_chains,
                    save_warmup = save_warmup,
                    thin=n_thin)
  }) %>% 
  setNames(names(sites)) %>% 
  saveRDS(file=here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_SpeciesLevelModels.rds"))) 
})
```


## Interval plots

### Variance partitioning

```{r PlotVarPart, fig.height=6,fig.width=10}
# Function to plot the intervals
plot_intervals <- function(ht_i,plot_title){
  
readRDS(file=here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_SpeciesLevelModels.rds"))) %>% 
  lapply(function(x){
    
  broom.mixed::tidyMCMC(x,pars=("pi"),
                droppars = NULL, 
                ess = F, rhat = F, 
                conf.int = T, conf.level = conf_level)  
  }) %>% 
  bind_rows(.id = "site") %>% 
  mutate(prop_var = case_when(term == "pi[1]" ~ "Residuals",
                              term == "pi[2]" ~ "Blocks",
                              term == "pi[3]" ~ "Populations",
                              term == "pi[4]" ~ "Families",
                              term == "pi[5]" ~ "Nurseries")) %>% 
  ggplot(aes(y = prop_var, x = estimate, xmin = conf.low, xmax = conf.high, color=site)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  ylab("") +
  xlab("Proportion of variance explained") +
  ggtitle(plot_title) +
  labs(color = "Field sites") +
  theme(axis.text = element_text(size=16),
        title = element_text(size=14),
        panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))
}

plot_intervals(ht_i = "HA14", plot_title = "Height in 2014")
plot_intervals(ht_i = "HA20", plot_title = "Height in 2020")
```


### Narrow-sense heritability ($h^2$)

```{r FunctionToPloth2AndISpeciesLevelModels}
plot_intervals_splevel <- function(param, x_axis){
  
  lapply(ht$codes, function(ht_i){
    readRDS(file=here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_SpeciesLevelModels.rds"))) %>%
      lapply(function(x){
        
        broom.mixed::tidyMCMC(x,pars=(param),
                              droppars = NULL, 
                              ess = F, rhat = F, 
                              conf.int = T, conf.level = conf_level)  
        }) %>% 
      bind_rows(.id = "site")   }) %>% 
    setNames(ht$codes) %>% 
    bind_rows(.id="ht") %>% 
    
    ggplot(aes(y = site, x = estimate, xmin = conf.low, xmax = conf.high, color=ht)) +
    geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
    ylab("") +
    xlab(x_axis) +
    scale_color_manual(name = "", values = ht$colors, labels = ht$names) +
    theme(axis.text = element_text(size=16),
          legend.text = element_text(size=14),
          title = element_text(size=14),
          panel.grid.minor.y=element_blank(),
          panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))
}
```

```{r IntervalPloth2SpeciesLevelModel, fig.height=5,fig.width=9}
plot_intervals_splevel(param="h2", x_axis = "Narrow-sense heritability")
```

### Evolvability ($I$)

```{r IntervalPlotISpeciesLevelModel, fig.height=5,fig.width=9}
plot_intervals_splevel(param="I", x_axis = "Evolvability")
```


# Population-level

In this section, we estimate the evolvability ($I$) and narrow-sense heritability ($h^2$) of each population.

```{r PopLevelParamsOfInterest}
# Parameters of interest
params <-c("I","h2","sigma2_fam")
param_names <- c("Evolvability", "Narrow-sense heritability", "Within-family variance")
names(param_names) <- params
```


## Using the full dataset

We first fit the models on the entire dataset.

### Population-specific models

#### Model equation

We fit one model per population.

Here is the model equation for a common garden with different nurseries. 
The model equation for a common garden with trees coming from one nursery is the same, without the nursery intercepts.

We model each trait $y$ such as:

\begin{equation}
\begin{aligned}
y_{bfnr} & \sim  \mathcal{N}(\mu_{bfn},\sigma^{2}_{r})\\[3pt]
\mu_{bpc} & =  \beta_{0} +  B_{b} + F_{f} + N_{n} \\[3pt]
\beta_{0} & \sim \mathcal{N}(\mu_{y},2)\\[3pt]
\begin{bmatrix} B_{b} \\ F_{f} \\ N_{n} \end{bmatrix} 
    & \sim \mathcal{N}\left(0,
\begin{bmatrix}
\sigma^{2}_{B}\\[3pt]
\sigma^{2}_{F}\\[3pt]
\sigma^{2}_{N}\\[3pt]
\end{bmatrix}
\right)\\
\end{aligned}
\end{equation}

$\beta_{0}$ is the global intercept.
$B_{b}$ are the block intercepts with a variance $\sigma^{2}_{B}$.
$F_{f}$ are the family intercepts with a variance $\sigma^{2}_{F}$.
$N_{n}$ are the nursery intercepts with a variance $\sigma^{2}_{N}$.
$\sigma^{2}_{r}$ is the residual variance.


Partitioning of the total variance $\sigma_{tot}^{2}$:

\begin{equation}
\begin{aligned}
\sigma_{tot}^{2} & = \sigma_{r}^{2} + \sigma_{B}^{2} + \sigma_{F}^{2} + \sigma_{N}^{2} \\[3pt]
\sigma_{r} & = \sigma_{tot} \times \sqrt(\pi_{r})\\[3pt]
\sigma_{B} & = \sigma_{tot} \times \sqrt(\pi_{B})\\[3pt]
\sigma_{F} & = \sigma_{tot} \times \sqrt(\pi_{F})\\[3pt]
\sigma_{N} & = \sigma_{tot} \times \sqrt(\pi_{N})\\[3pt]
\sigma_{tot} & \sim \mathcal{S}^{*}(0,1,3)
\end{aligned}
\end{equation}

with $\sum_{l}^{4}\pi_{l}=1$.

#### Stan code 

```{r StanCodePopSpecificModels, cache=T}
model_pop_specific_different_nurseries <- stan_model(here("scripts/stan_models/Evolvability_M2_DifferentNurseries.stan"))
model_pop_specific_one_nursery <- stan_model(here("scripts/stan_models/Evolvability_M2_OneNursery.stan"))
model_pop_specific_different_nurseries
```

#### Running the models

```{r RuningPopSpecificModels, eval=F}
lapply(ht$codes, function(ht_i){
  lapply(names(sites), function(site_i){
    
    subsubdata <- subdata %>% 
      filter(site==site_i & y_names == ht_i) %>% 
      drop_na(y_values) %>% 
      dplyr::select(-y_names) %>% 
      dplyr::rename(y=y_values) %>% 
      arrange(pop)
    
 lapply(unique(subsubdata$pop), function(pop_i){
   
   subpop <- subsubdata %>% 
    filter(pop==pop_i) 
   
   if(site_i %in% c("FE","FS")){ 
    model <- model_pop_specific_one_nursery
    pars <- c("pi", "h2", "I", #"beta0", "R_squared", 
              "alpha_block", "alpha_fam",
              "sigma2_r", "sigma2_block", "sigma2_fam", "sigma2_tot")
  } else if(site_i == "FW"){
    model <- model_pop_specific_different_nurseries
    pars <- c("pi", "h2", "I", #"beta0", "R_squared",
              "alpha_block", "alpha_fam", "alpha_nurs",
              "sigma2_r", "sigma2_block", "sigma2_fam", "sigma2_nurs", "sigma2_tot")
       }

 
  stanfit <- sampling(model,
                      data = compose_data(subpop),
                      pars=pars,
                      iter = n_iter, 
                      chains = n_chains, 
                      cores = n_chains,
                      save_warmup = save_warmup,
                      thin=n_thin)   
 }) %>% 
   setNames(unique(subsubdata$pop)) %>% 
   saveRDS(file=here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_",site_i,"_PopSpecificModels.rds")))
})
})
```

#### Extract params

```{r ExtractParamsPopSpecificModels, eval=F}
lapply(ht$codes, function(ht_i){
  lapply(names(sites), function(site_i){
    
    readRDS(file=here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_",site_i,"_PopSpecificModels.rds"))) %>% 
        lapply(function(pop_i){
          
          broom.mixed::tidyMCMC(pop_i, 
                                pars=params,
                                robust = TRUE, # median and mean absolute deviation
                                ess = F, rhat = F, 
                                conf.int = T, conf.level = conf_level) 
          
          }) %>% 
        bind_rows(.id = "pop") 
      }) %>% 
    setNames(names(sites)) %>% 
    bind_rows(.id = "site") 
  }) %>% 
    setNames(ht$codes) %>% 
    bind_rows(.id = "ht") %>% 
  saveRDS(here("outputs/ScotsPine/Evolvability/mcmc_params_pop_specific_models.rds"))
```

```{r LoadParamsPopSpecificModels}
mcmc_params_pop_specific_models <- readRDS(here("outputs/ScotsPine/Evolvability/mcmc_params_pop_specific_models.rds"))
```

#### Interval plots

##### Narrow-sense heritability


```{r Ploth2PopSpecificModels, fig.height=10,fig.width=8}
plot_intervals_poplevel <- function(ht_i, mcmc_draws, param, x_axis, plot_title){
  
  mcmc_draws %>% 
    filter(term == param & ht == ht_i) %>%
    
    ggplot(aes(y = pop, x = estimate, xmin = conf.low, xmax = conf.high,color=site)) + # invert x and y to get the populations on the x-axis
    geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
    ylab("") +
    xlab(x_axis) +
    ggtitle(plot_title) +
    theme(axis.text = element_text(size=16),
          legend.text = element_text(size=16),
          panel.grid.minor.y=element_blank(),
          panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))
}

plot_intervals_poplevel(ht_i = "HA14", 
                        mcmc_draws = mcmc_params_pop_specific_models,
                        param = "h2",
                        x_axis = "Narrow-sense heritability", 
                        plot_title = "Height in 2014")

plot_intervals_poplevel(ht_i = "HA20", 
                        mcmc_draws = mcmc_params_pop_specific_models,
                        param = "h2",
                        x_axis = "Narrow-sense heritability", 
                        plot_title = "Height in 2020")
```


#####  Evolvability


```{r PlotIOnePopSpecificModels, fig.height=10,fig.width=8}
plot_intervals_poplevel(ht_i = "HA14", 
                        mcmc_draws = mcmc_params_pop_specific_models,
                        param = "I",
                        x_axis = "Evolvability", 
                        plot_title = "Height in 2014")

plot_intervals_poplevel(ht_i = "HA20", 
                        mcmc_draws = mcmc_params_pop_specific_models,
                        param = "I",
                        x_axis = "Evolvability", 
                        plot_title = "Height in 2020")

```

#####  Within-family variance

```{r PlotSimga2FamPopSpecificModels, fig.height=10,fig.width=8}
plot_intervals_poplevel(ht_i = "HA14", 
                        mcmc_draws = mcmc_params_pop_specific_models,
                        param = "sigma2_fam",
                        x_axis = "Within-family variance", 
                        plot_title = "Height in 2014")

plot_intervals_poplevel(ht_i = "HA20", 
                        mcmc_draws = mcmc_params_pop_specific_models,
                        param = "sigma2_fam",
                        x_axis = "Within-family variance", 
                        plot_title = "Height in 2020")
```


### One model for all populations

#### Model equation

Here is the model equation for a common garden with different nurseries.

We modeled each trait $y_{bpfr}$ such as:

\begin{equation}
\begin{aligned}
y_{bpfnr} & \sim  \mathcal{N}(\mu_{bpfn},\sigma^{2}_{r})\\[3pt]
\mu_{bpfn} & =  \beta_{0} +  B_{b} + P_{p} + F_{f(p)} + N_{n}\\[3pt]
\end{aligned}
\end{equation}

$\beta_{0}$ is the global intercept.
$B_{b}$ are the block intercepts with a variance $\sigma^{2}_{B}$.
$P_{p}$ are the population intercepts with a variance  $\sigma^{2}_{P}$.
$F_{f}$ are the family intercepts with a variance $\sigma^{2}_{F}$.
$N_{n}$ are the nursery intercepts with a variance $\sigma^{2}_{N}$.
$\sigma^{2}_{r}$ is the residual variance.

The prior of $\beta_{0}$ was weakly informative and centered around the mean of the observed values for the trait under considered, as follows:

$$\beta_{0} \sim \mathcal{N}(\mu_{y},20)$$

The population, nursery and block intercepts, $P_{p}$, $N_{n}$ and $B_{b}$ were considered normally-distributed with variances $\sigma^{2}_{P}$, $\sigma^{2}_{N}$ and $\sigma^{2}_{B}$, such as:

$$\begin{bmatrix} B_{b} \\ P_{p} \\ N_{n} \end{bmatrix} 
    \sim \mathcal{N}\left(0,
\begin{bmatrix}\sigma^{2}_{B}\\[3pt]
\sigma^{2}_{P}\\
\sigma^{2}_{N}\\
\end{bmatrix}
\right)\\[3pt]$$

The family intercepts $F_{f(p)}$ were considered to follow some population-specific normal distributions, such as:
$$F_{f(p)} \sim \mathcal{N}(0,\sigma^{2}_{F_{p}})$$

where $\sigma^{2}_{F_{p}}$ are the population-specific variances among families.

To partition the total variance, we parameterize our model so that only the total variance, $\sigma_{tot}^{2}$ has a prior, such that:

\begin{equation}
\begin{aligned}
\sigma_{tot}^{2} & = \sigma_{r}^{2} + \sigma_{B}^{2} + \overline{\sigma_{F_{p}}}^{2} + \sigma_{P}^{2} + \sigma_{N}^{2}\\[3pt]
\sigma_{r} & = \sigma_{tot} \times \sqrt(\pi_{r})\\[3pt]
\sigma_{B} & = \sigma_{tot} \times \sqrt(\pi_{B})\\[3pt]
\sigma_{P} & = \sigma_{tot} \times \sqrt(\pi_{P})\\[3pt]
\sigma_{N} & = \sigma_{tot} \times \sqrt(\pi_{N})\\[3pt]
\overline{\sigma_{F_{p}}} & = \sigma_{tot} \times \sqrt(\pi_{F})\\[3pt]
\sigma_{tot} & \sim \mathcal{S}^{*}(0,1,3)
\end{aligned}
\end{equation}

where $\overline{\sigma_{F_{p}}}$ and $\overline{\sigma_{F_{p}}}^{2}$ are the mean of the population-specific among-family standard deviations ($\sigma_{F_{p}}$) and variances ($\sigma^{2}_{F_{p}}$), respectively, and $\sum_{l}^{5}\pi_{l}=1$ (using the `simplex` function in `Stan`).

The population-specific among-families standard deviations $\sigma_{F_{p}}$ follow a log-normal distribution with mean $\overline{\sigma_{F_{p}}}$ and variance $\sigma^{2}_{K}$, such as: 

\begin{equation*}
\begin{aligned}
\sigma_{F_{p}} & \sim \mathcal{LN}\left(\ln(\overline{\sigma_{F_{p}}})-\frac{\sigma^{2}_{K}}{2},\sigma^{2}_{K}\right)\\[3pt]
\sigma_{K} & \sim \exp(1)\\[3pt]
\end{aligned}
\end{equation*}


 
#### Stan code

```{r StancodeFullModel, cache=T}
model_all_pops_different_nurseries <- stan_model(here("scripts/stan_models/Evolvability_M3_DifferentNurseries.stan"))
model_all_pops_one_nursery <- stan_model(here("scripts/stan_models/Evolvability_M3_OneNursery.stan"))
model_all_pops_different_nurseries
```

#### Running the models

```{r RuningFullModel, eval=F}
lapply(ht$codes, function(ht_i){
  lapply(names(sites), function(site_i){
    
    subsubdata <- subdata %>% 
      filter(site==site_i & y_names == ht_i) %>% 
      drop_na(y_values) %>% 
      dplyr::select(-y_names) %>% 
      dplyr::rename(y=y_values) %>% 
      arrange(pop)
    
    if(site_i %in% c("FE","FS")){ 
      model <- model_all_pops_one_nursery
      pars <- c("beta0", "pi", 
                "bayes_R2_res", "bayes_R2",
                "h2_pop","I_pop",
                "alpha_bloc","alpha_pop","alpha_fam",
                "sigma2_r","sigma2_bloc","sigma2_pop","sigma2_fam")
      } else if(site_i == "FW"){
        model <- model_all_pops_different_nurseries
        pars <- c("beta0", "pi",
                  "bayes_R2_res", "bayes_R2",
                  "h2_pop","I_pop",
                  "alpha_bloc","alpha_pop","alpha_fam","alpha_nurs",
                  "sigma2_r","sigma2_bloc","sigma2_pop","sigma2_fam","sigma2_nurs")
        }
    
    stanlist <- compose_data(subsubdata)
    stanlist$which_pop <- as.numeric(as.factor(pull(unique(subsubdata[c("pop","fam")])[,"pop"])))
    stanlist$pop_mean <- subsubdata %>% group_by(pop) %>% summarise(pop_mean=mean(y)) %>% .[["pop_mean"]]
    
    stanfit <- sampling(model,
                        data = stanlist,
                        pars = pars,
                        iter = n_iter, 
                        chains = n_chains, 
                        cores = n_chains,
                        save_warmup = save_warmup,
                        thin = n_thin)
    }) %>% 
    setNames(names(sites)) %>%
    saveRDS(file=here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_FullModel.rds")))})
```

#### Model diagnostics

The models have divergent transitions, especially in Inverewe (FW). We can visualize the divergent transitions with pair plots. The divergent transitions correspond to the red crosses on the plots. 

```{r MCMCpairplotsFullModel, fig.height=8,fig.width=8}
# Function to draw pairs plots from MCMC draws
plot_mcmc_pairs <- function(ht_i, site_i, params){
  p <- readRDS(here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_FullModel.rds")))[[site_i]]
  
  mcmc_pairs(as.array(p), 
             np = nuts_params(p), 
             pars = params,
             off_diag_args = list(size = 0.75),
             grid_args = list(top = paste0(ht_i, " in ", sites[[site_i]])))
  }

# Plotting
lapply(ht$codes, function(ht_i){
  lapply(names(sites), function(site_i){
    lapply(list(c("pi[1]","pi[2]","pi[3]","pi[4]"),
                c("h2_pop[1]","I_pop[1]","sigma2_fam[1]")), function(params){
                  plot_mcmc_pairs(ht_i, site_i, params)
                  })
    })
  })
```

#### Extract params

```{r ExtractParamsOneFullModel, eval=F}
lapply(ht$codes, function(ht_i){
  
  readRDS(file=here(paste0("outputs/ScotsPine/Evolvability/StanModels/",ht_i,"_FullModel.rds"))) %>% 
      lapply(function(x){
        
        broom.mixed::tidyMCMC(x,
                              pars=c("I_pop","h2_pop","sigma2_fam"),
                              robust = TRUE, # median and mean absolute deviation
                              ess = F, rhat = F, 
                              conf.int = T, conf.level = conf_level) %>% 
          mutate(pop = rep(sort(unique(subdata$pop)),3)) %>% 
          mutate(term = case_when(grepl("I_pop", term) ~ "I",
                                  grepl("sigma2", term) ~ "sigma2_fam",
                                  grepl("h2", term) ~ "h2"))
      }) %>% 
      setNames(names(sites)) %>% 
      bind_rows(.id = "site") 

    }) %>% 
    setNames(ht$codes) %>% 
    bind_rows(.id = "ht") %>% 
  saveRDS(here("outputs/ScotsPine/Evolvability/mcmc_params_full_model.rds"))
```


```{r LoadParamsOneFullModel}
mcmc_params_full_model <- readRDS(here("outputs/ScotsPine/Evolvability/mcmc_params_full_model.rds"))
```

### Comparing estimates

We compare the credible intervals and check the correlations among the $h^2$, $I$ and $\sigma^2_{fam}$ estimates from the *population-specific models* and the *model with all populations*.


```{r ComparingEstimatesFullAndSeparateModels, fig.width=10, fig.height=14}
# Joining the MCMC draws from pop specific models and the full model (with all pops)
list_mcmc_params <- list(mcmc_params_pop_specific_models,
                         mcmc_params_full_model) %>% 
  setNames(c("Population-specific models",
             "One model with all populations")) %>%
  bind_rows(.id = "method") 

# Function to plot the intervals
plot_intervals_bothmodeltypes <- function(ht_i, param, list_mcmc_params){
  list_mcmc_params %>% 
    filter(term == param & ht == ht_i) %>% 
    ggplot(aes(x = estimate, y = pop, xmin = conf.low, xmax = conf.high, color=site, shape=method)) +
    geom_pointinterval(position = position_dodge(width = .6),point_size=3,alpha=0.6,size=5) +
    xlab(param_names[[param]]) +
    ylab("") +
    ggtitle(ht$names[[ht_i]]) +
    theme(axis.text = element_text(size=18),
          title = element_text(size=16),
          panel.grid.minor.x=element_blank(),
          panel.grid.major.x=element_blank())  +
    guides(color=guide_legend(ncol=1)) 

}

# Plot the intervals
lapply(params, function(param){
       lapply(ht$codes, function(ht_i){
         
         plot_intervals_bothmodeltypes(ht_i = ht_i, 
                              param = param,
                              list_mcmc_params = list_mcmc_params)
         })
  })
```


```{r CorrPlotsComparingEstimates, fig.width=6,fig.height=6,results='hide',fig.keep='all'}
# Function to plot the correlations
plot_correlations <- function(ht_i, param, list_mcmc_params){
  list_mcmc_params %>% 
    filter(term == param & ht == ht_i) %>% 
    mutate(method_site = paste0(method, " in ", site)) %>% 
    dplyr::select(estimate,method_site,pop) %>% 
    pivot_wider(names_from=method_site,values_from=estimate) %>% 
    dplyr::select(-pop) %>% 
    cor() %>% 
    corrplot(method = 'number',
             type = 'lower', diag = FALSE,
             mar=c(0,0,2,0),
             title=paste0(ht$names[[ht_i]]," - ",param_names[[param]]),
             number.cex=0.9,tl.cex=0.9)
}

# plot the correlations
lapply(params, function(param){
       lapply(ht$codes, function(ht_i){
         
         plot_correlations(ht_i = ht_i,
                           param = param,
                           list_mcmc_params = list_mcmc_params)
         })
  })
```

The estimation of the narrow-sense heritability incorporates uncertainty in the estimation of the family variance and the residual variance, so it has a higher uncertainty than the evolvability and the family variance. We may consider using the evolvavility or the family variance to compare the populations.

**Next step:** estimating the genetic parameters with a genomic relationship matrix. 