---
title: "Evolvability"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 11px
}
</style>

```{r setup, include=F}
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))
knitr::opts_chunk$set(cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(tidyverse)
library(here)
library(magrittr)
library(corrplot)
library(readxl)
library(rstan)
library(tidybayes)

library(bayesplot)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

theme_set(theme_bw(base_size = 20))

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
source(here("scripts/functions/make_spatialpoints_map.R"))
```


In the present report, we first estimate the narrow-sense heritability and evolvability at the species level, i.e. across all populations. Then we estimate these two parameters at the population level, i.e. one parameter value per population. For that, we first run one model per population (hereafter referred as 'population-specific models'). Second, we run a full model with all populations (hereafter referred as 'full model'), based on @archambeau2023reduced.

As heritability and evolvability are specific to the environment, the models are fitted in each common garden separately. We fit models that do not account for the nursery effect for the two common gardens in which trees come from the same nursery: the sites of **Yair (FS)** in the Scottish borders (in which all trees come from NG) and **Glensaugh (FE)** in which all trees come from NE (except four trees that come from NG and that we remove for the analyses).
  
We fit models that do account for the nursery effect in the common garden in which trees come from different nurseries: **Inverewe (FW)**, which contains cohorts of trees raised in each of the three nurseries as follows: 290 grown locally in the NW; 132 grown in the NG; and 82 grown in the NE.

 
# The data

For details on the data, see report `EstimatingPhenotypicPlasticityScotsPine.qmd`.


```{r LoadFieldandNurseryData}
# We load the field data
data <- read_excel(here("data/Field.xlsx"), na = "NA")

# we load the nursery data (dataset updated by Annika - 02/06/2023)
nursery_data <- read_excel(here("data/SPnurseries_updatedByAnnika02062023.xlsx")) %>% 
  dplyr::rename(FieldCode=Tag)

# we merge the two
data <- data %>% left_join(nursery_data, by=c("FieldCode")) 
```

We have to change the names of the block to specify that they are nested within sites:

```{r SiteSpecificBlocks}
# site-specific blocks
data <- data %>% mutate(Block = paste0(FieldSite,"_",Block))
```

According to @beaton2022phenotypic, there are **four randomised blocks in both FS and FE** and **three in FW**. We look at the number of individuals in each block:

```{r NumberOfIndividualsPerBlock}
data %>% group_by(Block) %>% summarise("Number of individuals"=n()) %>% kable_mydf()
```

We see that there is one typo in FW (block noted as `c` instead of `C`), that we have to correct:

```{r COrrectTypoBlocks}
data <- data %>% mutate(Block=case_when(Block=="FW_c" ~ "FW_C",
                                TRUE ~ Block))

data %>% group_by(Block) %>% summarise("Number of individuals"=n()) %>% kable_mydf()
```


In the present report, the estimation of heritability and evolvability is done for:

```{r ChosenTrait}
trait <- "HA20"
```

We subset the dataset by removing missing values for the trait considered and by removing the four trees in FE that belong to the NG nursery:

```{r Subdata}
site_codes <- unique(data$FieldSite)

subdata <- data %>% 
  dplyr::select(FieldSite,Block,PopulationCode,Family,Nursery,all_of(trait)) %>% 
  drop_na() %>% 
  dplyr::rename(site=FieldSite,
                bloc=Block,
                pop=PopulationCode,
                fam=Family,
                nurs=Nursery,
                y=any_of(trait)) %>% 
  filter(!(site=="FE" & nurs =="NG")) # we remove the four trees that come from the nursery NG in the field site FE
```

# Species-level parameters

In this section, we estimate evolvability ($I$) and narrow-sense heritability ($h^2$) at the species level, i.e. one value for all populations.

## Model equation


Here is the mathematical model of the model for a common garden with different nurseries. The mathematical model of the model for a common garden with trees coming from one nursery is the same, without the nursery intercepts.

We model each trait $y$ such as:

\begin{equation}
\begin{aligned}
y_{bpfnr} & \sim  \mathcal{N}(\mu_{bpfn},\sigma^{2}_{r})\\[3pt]
\mu_{bpc} & =  \beta_{0} +  B_{b} + P_{p} + F_{f} + N_{n} \\[3pt]
\beta_{0} & \sim \mathcal{N}(\mu_{y},2)\\[3pt]
\begin{bmatrix} B_{b} \\ P_{p} \\ F_{f} \\ N_{n} \end{bmatrix} 
    & \sim \mathcal{N}\left(0,
\begin{bmatrix}
\sigma^{2}_{B}\\[3pt]
\sigma^{2}_{P}\\[3pt]
\sigma^{2}_{F}\\[3pt]
\sigma^{2}_{N}\\[3pt]
\end{bmatrix}
\right)\\
\end{aligned}
\end{equation}

$\beta_{0}$ is the global intercept.
$B_{b}$ are the block intercepts with a variance $\sigma^{2}_{B}$.
$P_{p}$ are the population intercepts with a variance $\sigma^{2}_{P}$.
$F_{f}$ are the family intercepts with a variance $\sigma^{2}_{F}$.
$N_{n}$ are the nursery intercepts with a variance $\sigma^{2}_{N}$.
$\sigma^{2}_{r}$ is the residual variance.


Partitioning of the total variance $\sigma_{tot}^{2}$:

\begin{equation}
\begin{aligned}
\sigma_{tot}^{2} & = \sigma_{r}^{2} + \sigma_{B}^{2} + \sigma_{P}^{2} + \sigma_{F}^{2} + \sigma_{N}^{2} \\[3pt]
\sigma_{r} & = \sigma_{tot} \times \sqrt(\pi_{r})\\[3pt]
\sigma_{B} & = \sigma_{tot} \times \sqrt(\pi_{B})\\[3pt]
\sigma_{P} & = \sigma_{tot} \times \sqrt(\pi_{P})\\[3pt]
\sigma_{F} & = \sigma_{tot} \times \sqrt(\pi_{F})\\[3pt]
\sigma_{N} & = \sigma_{tot} \times \sqrt(\pi_{N})\\[3pt]
\sigma_{tot} & \sim \mathcal{S}^{*}(0,1,3)
\end{aligned}
\end{equation}

with $\sum_{l}^{5}\pi_{l}=1$.

Here is the Stan code of the model:

```{r StancodeSpeciesLevelModels}
model_different_nurseries <- stan_model(here("scripts/stan_models/StandardQuantGenModel_3.stan"))
model_one_nursery <- stan_model(here("scripts/stan_models/StandardQuantGenModel_4.stan"))
model_different_nurseries
```

## Running the models

Options for the Stan models:

```{r ModelOptions}
# Sampling in Bayesian models
n_chains <- 4 # number of chains (MCMC)
n_iter <- 2500 # number of iterations
n_warm <- 1250 # number of iterations in the warm-up phase
n_thin <- 1 # thinning interval
save_warmup <- FALSE 

# Credible intervals
conf_level <- 0.95
```


```{r RuningSpeciesLevelModel, eval=T}
lapply(site_codes, function(site_code){
  
  subsite <- subdata %>% 
    filter(site==site_code)
  
  if(site_code %in% c("FE","FS")){ 
    model <- model_one_nursery
    pars <- c("beta0", "pi", "R_squared", "h2","I",
              "alpha_block","alpha_pop","alpha_fam",
              "sigma2_r","sigma2_block","sigma2_pop","sigma2_fam","sigma2_tot")
  } else if(site_code=="FW"){
    model <- model_different_nurseries
    pars <- c("beta0", "pi", "R_squared", "h2","I",
              "alpha_block","alpha_pop","alpha_fam","alpha_nurs",
              "sigma2_r","sigma2_block","sigma2_pop","sigma2_fam","sigma2_nurs","sigma2_tot")
      
    }
  
  stanfit <- sampling(model,
                    data = compose_data(subsite),
                    pars=pars,
                    iter = n_iter, 
                    chains = n_chains, 
                    cores = n_chains,
                    save_warmup = save_warmup,
                    thin=n_thin)
}) %>% 
  setNames(site_codes) %>% 
  saveRDS(file=here(paste0("outputs/Evolvability/",trait,"_SpeciesLevelModels.rds")))
```

## Interval plots

> Variance partitioning

```{r PlotVarPart, fig.height=6,fig.width=10}
readRDS(file=here(paste0("outputs/Evolvability/",trait,"_SpeciesLevelModels.rds"))) %>% 
  lapply(function(x){
    
  broom.mixed::tidyMCMC(x,pars=("pi"),
                droppars = NULL, 
                ess = F, rhat = F, 
                conf.int = T, conf.level = conf_level)  
  }) %>% 
  bind_rows(.id = "site") %>% 
  mutate(prop_var = case_when(term == "pi[1]" ~ "Residuals",
                              term == "pi[2]" ~ "Blocks",
                              term == "pi[3]" ~ "Populations",
                              term == "pi[4]" ~ "Families",
                              term == "pi[5]" ~ "Nurseries")) %>% 
  ggplot(aes(y = prop_var, x = estimate, xmin = conf.low, xmax = conf.high, color=site)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  ylab("") +
  xlab("Proportion of variance explained") +
  labs(color = "Field sites") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))

```

> Narrow-sense heritability


```{r Ploth2, fig.height=4,fig.width=6}
readRDS(file=here(paste0("outputs/Evolvability/",trait,"_SpeciesLevelModels.rds"))) %>% 
  lapply(function(x){
    
  broom.mixed::tidyMCMC(x,pars=("h2"),
                droppars = NULL, 
                ess = F, rhat = F, 
                conf.int = T,conf.level = conf_level)  
  }) %>% 
  bind_rows(.id = "site") %>% 
  
  ggplot(aes(y = site, x = estimate, xmin = conf.low, xmax = conf.high)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  ylab("") +
  xlab("Narrow-sense heritability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))

```

> Evolvability

```{r PlotI, fig.height=4,fig.width=6}
readRDS(file=here(paste0("outputs/Evolvability/",trait,"_SpeciesLevelModels.rds"))) %>% 
  lapply(function(x){
    
  broom.mixed::tidyMCMC(x,pars=("I"),
                droppars = NULL, 
                ess = F, rhat = F, 
                conf.int = T,conf.level = conf_level)  
  }) %>% 
  bind_rows(.id = "site") %>% 
  
  ggplot(aes(y = site, x = estimate, xmin = conf.low, xmax = conf.high)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  ylab("") +
  xlab("Evolvability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank())  +
    guides(color=guide_legend(ncol=1))

```

# Population-specific parameters

In this section, we estimateevolvability ($I$) and narrow-sense heritability ($h^2$) at the population level, i.e. one value for each population.

## Full dataset

We first fit the models on the entire dataset.

### Population-specific models

We first fit one model per population.

Here is the model equation for a common garden with different nurseries. 
The model equation for a common garden with trees coming from one nursery is the same, without the nursery intercepts.

We model each trait $y$ such as:

\begin{equation}
\begin{aligned}
y_{bfnr} & \sim  \mathcal{N}(\mu_{bfn},\sigma^{2}_{r})\\[3pt]
\mu_{bpc} & =  \beta_{0} +  B_{b} + F_{f} + N_{n} \\[3pt]
\beta_{0} & \sim \mathcal{N}(\mu_{y},2)\\[3pt]
\begin{bmatrix} B_{b} \\ F_{f} \\ N_{n} \end{bmatrix} 
    & \sim \mathcal{N}\left(0,
\begin{bmatrix}
\sigma^{2}_{B}\\[3pt]
\sigma^{2}_{F}\\[3pt]
\sigma^{2}_{N}\\[3pt]
\end{bmatrix}
\right)\\
\end{aligned}
\end{equation}

$\beta_{0}$ is the global intercept.
$B_{b}$ are the block intercepts with a variance $\sigma^{2}_{B}$.
$F_{f}$ are the family intercepts with a variance $\sigma^{2}_{F}$.
$N_{n}$ are the nursery intercepts with a variance $\sigma^{2}_{N}$.
$\sigma^{2}_{r}$ is the residual variance.


Partitioning of the total variance $\sigma_{tot}^{2}$:

\begin{equation}
\begin{aligned}
\sigma_{tot}^{2} & = \sigma_{r}^{2} + \sigma_{B}^{2} + \sigma_{F}^{2} + \sigma_{N}^{2} \\[3pt]
\sigma_{r} & = \sigma_{tot} \times \sqrt(\pi_{r})\\[3pt]
\sigma_{B} & = \sigma_{tot} \times \sqrt(\pi_{B})\\[3pt]
\sigma_{F} & = \sigma_{tot} \times \sqrt(\pi_{F})\\[3pt]
\sigma_{N} & = \sigma_{tot} \times \sqrt(\pi_{N})\\[3pt]
\sigma_{tot} & \sim \mathcal{S}^{*}(0,1,3)
\end{aligned}
\end{equation}

with $\sum_{l}^{4}\pi_{l}=1$.

  
Stan code:

```{r StancodePopSpecificModel}
model_pop_specific_different_nurseries <- stan_model(here("scripts/stan_models/StandardQuantGenModel_5.stan"))
model_pop_specific_one_nursery <- stan_model(here("scripts/stan_models/StandardQuantGenModel_6.stan"))
model_pop_specific_different_nurseries
```

We run the models:

```{r RuningOnePopModel, eval=T}
lapply(site_codes, function(site_code){
  
 subsite <- subdata %>% 
    filter(site==site_code) %>% 
    arrange(pop)
  
 lapply(unique(subsite$pop), function(pop_i){
   
   subpop <- subsite %>% 
    filter(pop==pop_i) 
   
   if(site_code %in% c("FE","FS")){ 
    model <- model_pop_specific_one_nursery
    pars <- c("beta0", "pi", "R_squared", "h2","I",
              "alpha_block","alpha_fam",
              "sigma2_r","sigma2_block","sigma2_fam","sigma2_tot")
  } else if(site_code=="FW"){
    model <- model_pop_specific_different_nurseries
    pars <- c("beta0", "pi", "R_squared", "h2","I",
              "alpha_block","alpha_fam","alpha_nurs",
              "sigma2_r","sigma2_block","sigma2_fam","sigma2_nurs","sigma2_tot")
       }

 
  stanfit <- sampling(model,
                      data = compose_data(subpop),
                      pars=pars,
                      iter = n_iter, 
                      chains = n_chains, 
                      cores = n_chains,
                      save_warmup = save_warmup,
                      thin=n_thin)   
 }) %>% 
   setNames(unique(subsite$pop))
}) %>% 
  setNames(site_codes) %>% 
  saveRDS(file=here(paste0("outputs/Evolvability/",trait,"_PopSpecificModels.rds")))
```


#### Interval plots

> Narrow-sense heritability


```{r Ploth2PopSpecificModel, fig.height=6,fig.width=12}
df <- readRDS(file=here(paste0("outputs/Evolvability/",trait,"_PopSpecificModels.rds"))) %>% 
  lapply(function(site_i){
    
    site_i %>% lapply(function(pop_i){
    
  broom.mixed::tidyMCMC(pop_i,pars=("h2"),
                droppars = NULL, 
                ess = F, rhat = F, 
                conf.int = T,conf.level = conf_level) 
      
    }) %>% bind_rows(.id = "pop")
  }) %>% bind_rows(.id = "site")


  
# df %>%   
#   ggplot(aes(y = pop, x = estimate, xmin = conf.low, xmax = conf.high,color=site)) +
#   geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
#   ylab("") +
#   xlab("Narrow-sense heritability") +
#   theme(axis.text = element_text(size=18),
#         panel.grid.minor.y=element_blank(),
#         panel.grid.major.y=element_blank())  +
#     guides(color=guide_legend(ncol=1))


df %>%   
  ggplot(aes(y = estimate, x = pop, ymin = conf.low, ymax = conf.high,color=site)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  xlab("") +
  ylab("Narrow-sense heritability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())  +
    guides(color=guide_legend(ncol=1))

```


> Evolvability


```{r PlotIOnePopModel, fig.height=6,fig.width=12}
df <- readRDS(file=here(paste0("outputs/Evolvability/",trait,"_PopSpecificModels.rds"))) %>% 
  lapply(function(site_i){
    
    site_i %>% lapply(function(pop_i){
    
  broom.mixed::tidyMCMC(pop_i,pars=("I"),
                droppars = NULL, 
                ess = F, rhat = F, 
                conf.int = T,conf.level = conf_level) 
      
    }) %>% bind_rows(.id = "pop")
  }) %>% bind_rows(.id = "site")
  
# 
# df %>% ggplot(aes(y = pop, x = estimate, xmin = conf.low, xmax = conf.high,color=site)) +
#   geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
#   ylab("") +
#   xlab("Evolvability") +
#   theme(axis.text = element_text(size=18),
#         panel.grid.minor.y=element_blank(),
#         panel.grid.major.y=element_blank())  +
#     guides(color=guide_legend(ncol=1))


df %>%  ggplot(aes(y = estimate, x = pop, ymin = conf.low, ymax = conf.high,color=site)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  xlab("") +
  ylab("Evolvability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())  +
    guides(color=guide_legend(ncol=1))

```

### Full model

Here is the model equation for a common garden with different nurseries.

We modeled each trait $y_{bpfr}$ such as:

\begin{equation}
\begin{aligned}
y_{bpfnr} & \sim  \mathcal{N}(\mu_{bpfn},\sigma^{2}_{r})\\[3pt]
\mu_{bpfn} & =  \beta_{0} +  B_{b} + P_{p} + F_{f(p)} + N_{n}\\[3pt]
\end{aligned}
\end{equation}

$\beta_{0}$ is the global intercept.
$B_{b}$ are the block intercepts with a variance $\sigma^{2}_{B}$.
$P_{p}$ are the population intercepts with a variance  $\sigma^{2}_{P}$.
$F_{f}$ are the family intercepts with a variance $\sigma^{2}_{F}$.
$N_{n}$ are the nursery intercepts with a variance $\sigma^{2}_{N}$.
$\sigma^{2}_{r}$ is the residual variance.

The prior of $\beta_{0}$ was weakly informative and centered around the mean of the observed values for the trait under considered, as follows:

$$\beta_{0} \sim \mathcal{N}(\mu_{y},20)$$

The population, nursery and block intercepts, $P_{p}$, $N_{n}$ and $B_{b}$ were considered normally-distributed with variances $\sigma^{2}_{P}$, $\sigma^{2}_{N}$ and $\sigma^{2}_{B}$, such as:

$$\begin{bmatrix} B_{b} \\ P_{p} \\ N_{n} \end{bmatrix} 
    \sim \mathcal{N}\left(0,
\begin{bmatrix}\sigma^{2}_{B}\\[3pt]
\sigma^{2}_{P}\\
\sigma^{2}_{N}\\
\end{bmatrix}
\right)\\[3pt]$$

The family intercepts $F_{f(p)}$ were considered to follow some population-specific normal distributions, such as:
$$F_{f(p)} \sim \mathcal{N}(0,\sigma^{2}_{F_{p}})$$

where $\sigma^{2}_{F_{p}}$ are the population-specific variances among families.

To partition the total variance, we parameterize our model so that only the total variance, $\sigma_{tot}^{2}$ has a prior, such that:

\begin{equation}
\begin{aligned}
\sigma_{tot}^{2} & = \sigma_{r}^{2} + \sigma_{B}^{2} + \overline{\sigma_{F_{p}}}^{2} + \sigma_{P}^{2} + \sigma_{N}^{2}\\[3pt]
\sigma_{r} & = \sigma_{tot} \times \sqrt(\pi_{r})\\[3pt]
\sigma_{B} & = \sigma_{tot} \times \sqrt(\pi_{B})\\[3pt]
\sigma_{P} & = \sigma_{tot} \times \sqrt(\pi_{P})\\[3pt]
\sigma_{N} & = \sigma_{tot} \times \sqrt(\pi_{N})\\[3pt]
\overline{\sigma_{F_{p}}} & = \sigma_{tot} \times \sqrt(\pi_{F})\\[3pt]
\sigma_{tot} & \sim \mathcal{S}^{*}(0,1,3)
\end{aligned}
\end{equation}

where $\overline{\sigma_{F_{p}}}$ and $\overline{\sigma_{F_{p}}}^{2}$ are the mean of the population-specific among-family standard deviations ($\sigma_{F_{p}}$) and variances ($\sigma^{2}_{F_{p}}$), respectively, and $\sum_{l}^{5}\pi_{l}=1$ (using the `simplex` function in `Stan`).

The population-specific among-families standard deviations $\sigma_{F_{p}}$ follow a log-normal distribution with mean $\overline{\sigma_{F_{p}}}$ and variance $\sigma^{2}_{K}$, such as: 

\begin{equation*}
\begin{aligned}
\sigma_{F_{p}} & \sim \mathcal{LN}\left(\ln(\overline{\sigma_{F_{p}}})-\frac{\sigma^{2}_{K}}{2},\sigma^{2}_{K}\right)\\[3pt]
\sigma_{K} & \sim \exp(1)\\[3pt]
\end{aligned}
\end{equation*}


 
Stan code of the models:

```{r StancodeFullModel}
model_all_pops_different_nurseries <- stan_model(here("scripts/stan_models/StandardQuantGenModel_8.stan"))
model_all_pops_one_nursery <- stan_model(here("scripts/stan_models/StandardQuantGenModel_7.stan"))
model_all_pops_different_nurseries 
```

```{r RuningFullModel, eval=T}
lapply(site_codes, function(site_code){
  
  
  subsite <- subdata %>% 
    filter(site==site_code) %>% 
    arrange(pop)
  
  if(site_code %in% c("FE","FS")){ 
    model <- model_all_pops_one_nursery
    pars <- c("beta0", "pi", 
              "bayes_R2_res", "bayes_R2",
              "h2_pop","I_pop",
              "alpha_bloc","alpha_pop","alpha_fam",
              "sigma2_r","sigma2_bloc","sigma2_pop","sigma2_fam")
  } else if(site_code=="FW"){
    model <- model_all_pops_different_nurseries
    pars <- c("beta0", "pi", 
              "bayes_R2_res", "bayes_R2",
              "h2_pop","I_pop",
              "alpha_bloc","alpha_pop","alpha_fam","alpha_nurs",
              "sigma2_r","sigma2_bloc","sigma2_pop","sigma2_fam","sigma2_nurs")
      
  }
  
  stanlist <- compose_data(subsite)
  
  stanlist$which_pop <- as.numeric(as.factor(pull(unique(subsite[c("pop","fam")])[,"pop"])))
  
  stanfit <- sampling(model,
                      data = stanlist,
                      pars=pars,
                      iter = n_iter, 
                      chains = n_chains, 
                      cores = n_chains,
                      save_warmup = save_warmup,
                      thin=n_thin)
}) %>% 
  setNames(site_codes) %>% 
  saveRDS(file=here(paste0("outputs/Evolvability/",trait,"_FullModel.rds")))
```

The models have divergent transitions. We can visualize them with pairs plots.

```{r MCMCpairplotsFullModel, fig.height=8,fig.width=8}
readRDS(here(paste0("outputs/Evolvability/",trait,"_FullModel.rds"))) %>% 
lapply(function(x){
 mcmc_pairs(as.array(x), 
           np = nuts_params(x), 
           pars = c("pi[1]","pi[2]","pi[3]","pi[4]"),
           off_diag_args = list(size = 0.75)) 
  
})
```


## Comparing $h^2$ and $I$ estimates

We check the correlations among $h^2$ and $I$ values estimated calculated with *population-specific models* or with the *full model* including all populations.


```{r ComparingEstimatesFullAndSeparateModels, fig.width=16, fig.height=10}

list_df <- lapply(c("I","h2"), function(x){
  

# Extract the median estimates of h2/I in the population-specific models
# ======================================================================
df_pop_specific_models <- readRDS(file=here(paste0("outputs/Evolvability/",trait,"_PopSpecificModels.rds"))) %>% 
  lapply(function(site_i){
    
    site_i %>% lapply(function(pop_i){
    
  broom.mixed::tidyMCMC(pop_i,pars=(x),
                droppars = NULL, ess = F, rhat = F, conf.int = T,conf.level = conf_level) 
      
    }) %>% bind_rows(.id = "pop")
  }) %>% bind_rows(.id = "site") %>% 
  mutate(model="pop_specific_models") %>% 
  mutate(model_site=paste0(model,"_",site)) %>% 
  dplyr::select(-term)

# Extract the median estimates of h2/I in the population-specific models
# ======================================================================
df <- readRDS(here(paste0("outputs/Evolvability/",trait,"_FullModel.rds"))) %>%
  lapply(function(site_i){
    
  broom.mixed::tidyMCMC(site_i,pars=(paste0(x,"_pop")),
                droppars = NULL, ess = F, rhat = F, conf.int = T,conf.level = conf_level) 
      
  }) %>% 
  bind_rows(.id = "site") %>% 
  mutate(model="full_model") %>% 
  mutate(model_site=paste0(model,"_",site)) %>% 
  mutate(pop=rep(unique(subdata$pop) %>% sort,3)) %>% 
  dplyr::select(-term) %>% 
  bind_rows(df_pop_specific_models)

  
}) %>% setNames(c("I","h2"))


list_df[["h2"]] %>%   
  ggplot(aes(y = estimate, x = pop, ymin = conf.low, ymax = conf.high,color=site,shape=model)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  xlab("") +
  ylab("Narrow-sense heritability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())  +
    guides(color=guide_legend(ncol=1))

list_df[["I"]] %>%   
  ggplot(aes(y = estimate, x = pop, ymin = conf.low, ymax = conf.high,color=site,shape=model)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  xlab("") +
  ylab("Evolvability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())  +
    guides(color=guide_legend(ncol=1))
```

```{r COrrPlotsComparingEstimates, fig.width=6,fig.height=6}
list_df[["I"]] %>% 
  dplyr::select(estimate,model_site,pop) %>% 
  pivot_wider(names_from=model_site,values_from=estimate) %>% 
  dplyr::select(-pop) %>% 
  cor() %>% 
  corrplot(method = 'number',
           type = 'lower', diag = FALSE,
           mar=c(0,0,2,0),
           title="Evolvability",
           number.cex=0.9,tl.cex=0.9)

list_df[["h2"]] %>% 
  dplyr::select(estimate,model_site,pop) %>% 
  pivot_wider(names_from=model_site,values_from=estimate) %>% 
  dplyr::select(-pop) %>% 
  cor() %>% 
  corrplot(method = 'number',
           type = 'lower', diag = FALSE,
           mar=c(0,0,2,0),
           title="Narrow-sense heritability",
           number.cex=0.9,tl.cex=0.9)
```


# Population-specific models - filtered datasets

One potential explanation for the divergent transitions is the insufficient number of individuals in some families or families in populations.

## Sample size

We look at the number of individuals in each family and we count the number of families with 1, 2, 3 or 4 individuals:

```{r NumberIndividualsPerFamily}
nb_ind_per_family <- lapply(site_codes, function(site_code){
  
  subdata %>%
    filter(site == site_code) %>% 
    group_by(fam) %>% 
    summarise(nb_individual_per_family=n())  %>% 
    group_by(nb_individual_per_family) %>% 
    summarise(nb_family=n()) %>% 
    setNames(c("Number of individuals per family", "Number of families"))
}) %>% setNames(site_codes)
```

In FE:

```{r}
nb_ind_per_family[["FE"]] %>%  kable_mydf
```

In FS:


```{r}
nb_ind_per_family[["FS"]] %>%  kable_mydf
```

We also look at the number of families per population:

```{r NumberFamilyPerPop}
nb_fam_per_pop <- lapply(site_codes, function(site_code){
  
  subdata %>%
    filter(site == site_code) %>% 
    dplyr::select(pop,fam) %>% 
    distinct() %>% 
    group_by(pop) %>% 
    summarise(nb_fam_per_pop=n()) %>% 
    setNames(c("Population", "Number of families per population"))
}) %>% setNames(site_codes)
```

In FE:


```{r}
nb_fam_per_pop[["FE"]] %>%  kable_mydf
```


In FS:

```{r}
nb_fam_per_pop[["FS"]] %>%  kable_mydf
```

## Keeping only families with 4 individuals

We fit again the models with only families in which there are 4 individuals, so only in FE and FS.

We identify the families with four individuals:

```{r SelectedFamilieFilteredDatasets}
site_codes <- c("FE","FS")

selected_families <- lapply(site_codes, function(site_code){
  
  subdata %>%
    filter(site == site_code) %>% 
    group_by(fam) %>% 
    summarise(nb_individual_per_family=n()) %>% 
    filter(nb_individual_per_family==4) %>% 
    pull(fam)
}) %>% setNames(site_codes)
```


We look at the trait distribution after keeping only populations with 4 individuals.

```{r TraitDistributionAfterFiltering}
  subdata %>%
    filter(site %in% site_codes) %>% 
    filter((site == "FE" & fam %in% selected_families[["FE"]]) |
           (site == "FS" & fam %in% selected_families[["FS"]])) %>% 
    ggplot(aes(x=y)) +  
    geom_histogram(aes(y=after_stat(density)), colour="blue",fill="white",bins = 34) +
    geom_density(alpha=.2,fill="pink") +
    ggtitle(paste0(trait," distribution after keeping only populations with 4 individuals")) +
    facet_wrap(~site,scales="free") + 
    theme_bw() 
```

We run the population-specific models and the full models:

```{r RunningModelsFilteredDatasets, eval=T}
lapply(site_codes, function(site_code){
  
  subdata %>%
    filter(site == site_code) %>% 
    filter(fam %in% selected_families[[site_code]]) %>% 
    dplyr::select(pop,fam) %>% 
    distinct() %>% 
    group_by(pop) %>% 
    summarise(nb_fam_per_pop=n()) %>% 
    group_by(nb_fam_per_pop) %>% 
    summarise(nb_family=n())
}) %>% setNames(site_codes)





  # Population-specific models
  # ==========================
lapply(site_codes, function(site_code){
  
 subsite <- subdata %>% 
    filter(site==site_code) %>% 
    filter(fam %in% selected_families[[site_code]]) %>% 
    dplyr::select(bloc, pop, fam, y) %>% 
    arrange(pop)
  
 lapply(unique(subsite$pop), function(pop_i){
   
   subpop <- subsite %>% 
    filter(pop==pop_i) 
   
    model <- model_pop_specific_one_nursery
    pars <- c("beta0", "pi", "R_squared", "h2","I",
              "alpha_block","alpha_fam",
              "sigma2_r","sigma2_block","sigma2_fam","sigma2_tot")
 
  stanfit <- sampling(model,
                      data = compose_data(subpop),
                      pars=pars,
                      iter = n_iter, 
                      chains = n_chains, 
                      cores = n_chains,
                      save_warmup = save_warmup,
                      thin=n_thin)   
 }) %>% 
   setNames(unique(subsite$pop))
}) %>% 
    setNames(site_codes) %>% 
    saveRDS(file=here(paste0("outputs/Evolvability/",trait,"_PopSpecificModels_FilteredDataset.rds")))
  
  
    # Full model
    # ==========
  
lapply(site_codes, function(site_code){
  
  
  subsite <- subdata %>% 
    filter(site==site_code) %>% 
    filter(fam %in% selected_families[[site_code]]) %>% 
    dplyr::select(bloc, pop, fam, y) %>% 
    arrange(pop)
  
    model <- model_all_pops_one_nursery
    pars <- c("beta0", "pi", 
              "bayes_R2_res", "bayes_R2",
              "h2_pop","I_pop",
              "alpha_bloc","alpha_pop","alpha_fam",
              "sigma2_r","sigma2_bloc","sigma2_pop","sigma2_fam")

  
  stanlist <- compose_data(subsite)
  
  stanlist$which_pop <- as.numeric(as.factor(pull(unique(subsite[c("pop","fam")])[,"pop"])))
  
  stanfit <- sampling(model,
                      data = stanlist,
                      pars=pars,
                      iter = n_iter, 
                      chains = n_chains, 
                      cores = n_chains,
                      save_warmup = save_warmup,
                      thin=n_thin)
}) %>% 
  setNames(site_codes) %>% 
  saveRDS(file=here(paste0("outputs/Evolvability/",trait,"_FullModel_FilteredDataset.rds")))
```


```{r MCMCpairplotsFilteredDatasets, fig.height=8,fig.width=8}
readRDS(here(paste0("outputs/Evolvability/",trait,"_FullModel_FilteredDataset.rds"))) %>% 
lapply(function(x){
 mcmc_pairs(as.array(x), 
           np = nuts_params(x), 
           pars = c("pi[1]","pi[2]","pi[3]","pi[4]"),
           off_diag_args = list(size = 0.75)) 
  
})

readRDS(here(paste0("outputs/Evolvability/",trait,"_FullModel_FilteredDataset.rds"))) %>% 
lapply(function(x){
 mcmc_pairs(as.array(x), 
           np = nuts_params(x), 
           pars = c("alpha_pop[2]","h2_pop[2]","h2_pop[17]","sigma2_r"),
           off_diag_args = list(size = 0.75)) 
  
})
```


## Comparing estimates 

We check the correlations between $h^2$ and $I$ estimated *population-specific models* or with the *full model* including all populations.



```{r ComparingEstimatesFullAndSeparateModelsFilteredDataset, fig.width=16, fig.height=10}

list_df <- lapply(c("I","h2"), function(x){
  

# Extract the median estimates of h2/I in the population-specific models
# ======================================================================
df_pop_specific_models <- readRDS(file=here(paste0("outputs/Evolvability/",trait,"_PopSpecificModels_FilteredDataset.rds"))) %>% 
  lapply(function(site_i){
    
    site_i %>% lapply(function(pop_i){
    
  broom.mixed::tidyMCMC(pop_i,pars=(x),
                droppars = NULL, ess = F, rhat = F, conf.int = T,conf.level = conf_level) 
      
    }) %>% bind_rows(.id = "pop")
  }) %>% bind_rows(.id = "site") %>% 
  mutate(model="pop_specific_models") %>% 
  mutate(model_site=paste0(model,"_",site)) %>% 
  dplyr::select(-term)

# Extract the median estimates of h2/I in the population-specific models
# ======================================================================
df <- readRDS(here(paste0("outputs/Evolvability/",trait,"_FullModel_FilteredDataset.rds"))) %>%
  lapply(function(site_i){
    
  broom.mixed::tidyMCMC(site_i,pars=(paste0(x,"_pop")),
                droppars = NULL, ess = F, rhat = F, conf.int = T,conf.level = conf_level) 
      
  }) %>% 
  bind_rows(.id = "site") %>% 
  mutate(model="full_model") %>% 
  mutate(model_site=paste0(model,"_",site)) %>% 
  mutate(pop=rep(unique(subdata$pop) %>% sort,2)) %>% 
  dplyr::select(-term) %>% 
  bind_rows(df_pop_specific_models)

  
}) %>% setNames(c("I","h2"))


list_df[["h2"]] %>%   
  ggplot(aes(y = estimate, x = pop, ymin = conf.low, ymax = conf.high,color=site,shape=model)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  xlab("") +
  ylab("Narrow-sense heritability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())  +
    guides(color=guide_legend(ncol=1))

list_df[["I"]] %>%   
  ggplot(aes(y = estimate, x = pop, ymin = conf.low, ymax = conf.high,color=site,shape=model)) +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3,alpha=0.6,size=5) +
  xlab("") +
  ylab("Evolvability") +
  theme(axis.text = element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())  +
    guides(color=guide_legend(ncol=1))
```

```{r CorrPlotsComparingEstimatesFilteredDataset, fig.width=6,fig.height=6}
list_df[["I"]] %>% 
  dplyr::select(estimate,model_site,pop) %>% 
  pivot_wider(names_from=model_site,values_from=estimate) %>% 
  dplyr::select(-pop) %>% 
  cor() %>% 
  corrplot(method = 'number',
           type = 'lower', diag = FALSE,
           mar=c(0,0,2,0),
           title="Evolvability",
           number.cex=0.9,tl.cex=0.9)

list_df[["h2"]] %>% 
  dplyr::select(estimate,model_site,pop) %>% 
  pivot_wider(names_from=model_site,values_from=estimate) %>% 
  dplyr::select(-pop) %>% 
  cor() %>% 
  corrplot(method = 'number',
           type = 'lower', diag = FALSE,
           mar=c(0,0,2,0),
           title="Narrow-sense heritability",
           number.cex=0.9,tl.cex=0.9)
```

