// Estimating population-specific heritabilities and evolvabilities in the common gardens with trees from the same nursery

data {
  int<lower=1> n;                                                              // Number of observations
  vector[n] y;                                                                 // Response variable
  int<lower=0> n_bloc;                                                         // Number of blocks
  int<lower=0> n_pop;                                                          // Number of populations
  int<lower=0> n_fam;                                                          // Number of families
  int<lower=0, upper=n_bloc> bloc[n];                                          // Blocks
  int<lower=0, upper=n_pop> pop[n];                                            // Populations
  int<lower=0, upper=n_pop> which_pop[n_fam];                                  // Populations
  vector[n_pop] pop_mean;                                                      // Mean of the populations
  int<lower=0, upper=n_fam> fam[n];                                            // Families
}


parameters {
  real beta0; // global intercept
  simplex[4] pi;
  real<lower = 0> sigma_tot;
  real<lower = 0> sigma_K;
  vector[n_pop] z_log_sigma_fam;
  
  vector[n_bloc] z_bloc;
  vector[n_pop] z_pop;
  vector[n_fam] z_fam;
  
}


transformed parameters {
  real R_squared;
  
  real<lower = 0>  sigma_r;
  real<lower = 0>  sigma_bloc;
  real<lower = 0>  sigma_pop;
  
  real mean_sigma_fam;
  vector[n_pop] sigma_fam;
  
  vector[n_pop] alpha_pop;
  vector[n_fam] alpha_fam;
  vector[n_bloc] alpha_bloc;
  
  vector[n] mu; // linear predictor
  
  // variance partitioning with the simplex pi
  sigma_r = sqrt(pi[1]) * sigma_tot;
  sigma_bloc = sqrt(pi[2]) * sigma_tot;
  sigma_pop = sqrt(pi[3]) * sigma_tot;
  
  mean_sigma_fam= sqrt(pi[4]) * sigma_tot;
  sigma_fam = exp(log(mean_sigma_fam) - (square(sigma_K)/2)  + z_log_sigma_fam*sigma_K);
  
  alpha_pop = z_pop*sigma_pop;
  
  for(f in 1:n_fam){
    alpha_fam[f] =  z_fam[f]*sigma_fam[which_pop[f]];
  }
  
  alpha_bloc = z_bloc*sigma_bloc;
  
  mu = rep_vector(beta0, n) + alpha_fam[fam] + alpha_bloc[bloc] + alpha_pop[pop];
  R_squared = 1 - variance(y - mu) / variance(y);
}

model{
  //Priors
  beta0 ~ normal(mean(y),20);
  sigma_tot ~ student_t(3, 0.0, 1.0);
  
  z_pop ~ std_normal();
  z_bloc ~ std_normal();
  z_fam ~ std_normal();
  
  z_log_sigma_fam ~ std_normal();
  sigma_K ~ exponential(1);
  
  // Likelihood
  y ~ normal(mu, sigma_r);
}


generated quantities {
  //Variances
  real<lower=0> sigma2_r;
  real<lower=0> sigma2_pop;
  real<lower=0> sigma2_bloc;
  vector[n_pop] sigma2_fam;
  
  // Heritability
  vector[n_pop] h2_pop;
  
  // Evolvability
  vector[n_pop] I_pop;
  
  // Posterior predictive check
  vector[n] y_rep;
  
  // Log-Likelihood (for WAIC/loo computations)
  //vector[n] log_lik;
  
  // Bayesian R2
  real bayes_R2_res; // residual based R2
  real bayes_R2;     // model based R2, i.e.  using modelled (approximate) residual variance
  
  sigma2_r = square(sigma_r);
  sigma2_pop = square(sigma_pop);
  sigma2_fam = square(sigma_fam);
  for(p in 1:n_pop)  h2_pop[p] = (4*sigma2_fam[p])/(sigma2_r+sigma2_fam[p]);
  for(p in 1:n_pop)  I_pop[p] = (4*sigma2_fam[p])/(pop_mean[p]^2);// should we divide by the mean(y) of each population?
  sigma2_bloc = square(sigma_bloc);
  for(i in 1:n)  {
    y_rep[i] = normal_rng(mu[i], sigma_r);
    //log_lik[i] = normal_lpdf(y[i]| mu[i], sigma_r); // log probability density function
  }
  
  bayes_R2_res = variance(mu) / (variance(mu) + variance(y-mu));
  bayes_R2 = variance(mu) / (variance(mu) + sigma2_r);
  
}

